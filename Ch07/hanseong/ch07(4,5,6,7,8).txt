================================== [ 7장 객체지향 프로그래밍 2] ==================================

[4. 제어자(modifier) ]

# 4-1 제어자란?
	* 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여하는 형용사 역할

	* 접근제어자와 그 외 제어자 2개로 나뉜다
		// 접근제어자는 1개만 사용할 수 있다
		// 그 외 제어자는 여러개를 조합하여 사용 접근제어자 1개와 함께 사용할 수 있다

	* 순서는 관계 없지만 접근제어자를 맨 앞에 사용하는 것이 관례이다

# 4-2 static - 클래스의, 공통적인
	* static은 '클래스의' 또는 '공통적인'의 의미

	* static이 붙은 멤버변수, 메서드, 초기화 블럭은 인스턴스를 생성하지 않고도 사용할 수 있다

	* static이 사용될 수 있는 곳 - 멤버변수,메서드,초기화블럭

	* 메서드에서 인스턴스변수를 사용하지 않으면 static 메서드로 하는것이 좋다
		// 인스턴스를 생성하지 않아서 속도가 더 빠름

# 4-3 final - 마지막의, 변경될 수 없는
	* final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

	* 변수에 사용되면 값을 변경할 수 없는 '상수'

	* 메서드에 사용되면 오버라이딩 할 수 없다

	* 클래스에 사용되면 그 클래스는 부모 클래스가 될 수 없다
		// ex) String, Math 클래스

# 4-3-1 생성자를 이용한 final멤벼 변수의 초기화
	* final이 붙은 변수는 상수이므로 일반적으로 명시적 초기화를 한다
		// 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다

	* 생성자를 이용해 final이 붙은 멤버변수를 초기화한다
		// 객체를 만들때 한번만 초기화 할 수 있다

	* 상수는 한번 초기화하면 변경할 수 없다
		// 인스턴스변수, 클래스변수는 변경 가능

# 4-4 abstract - 추상의, 미완성의
	* 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용
		// 추상메서드가 하나라도 있으면 추상클래스가 된다
		// 추상클래스는 구현하지 않은 메서드가 있다는 걸 뜻한다

	* 추상클래스로 객체를 만들지 못한다
		// 상속받아서 추상메서드를 오버라이딩한 클래스는 인스턴스화 가능

# 4-5 접근 제어자(access modifier) 
	* 접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할

	* 클래스 		: private, (default)
	  메서드 멤버변수 	: 모두 가능

	* 접근제어자가 default임을 알리기 위해 default를 붙히지 않는다

	* 접근제어자의 범위
		1) private : 같은 클래스 내에서만 접근 가능
		2) default : 같은 패키지 내에서만 접근 가능
		3) protected : 같은 패키지, 다른패키지 자손에서만 접근 가능
		4) public : 모든 영역에서 접근 가능

# 4-5-1 접근 제어자를 이용한 캡슐화
	* 접근제어자를 사용하는 이유(캡슐화 하는 이유)
		// 외부로부터 데이터를 보호하기 위해서
			- 올바르지 않은 값이 넘어오는것을 방지
			- 유효성 검사를 통한 멤버초기화 가능(setter)
		// 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

	* 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에서 선언된 데이터를 보호하기 위해서이다

# 4-5-2 생성자의 접근 제어자
	* 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다(singleton)
		// 그 클래스 내부에서는 인스턴스를 생성할 수 있다.

	* 클래스변수로 자신을 객체화 하고 - public을 가진 static메서드를 만들어서 자신의 타입을 반환타입으로 지정한 후
	  - 위에서 초기화한 참조변수를 리턴한다. 
		// 다른 클래스에서 singleton클래스를 인스턴스화 하는 방법
			- 클래스명 참조변수명 = 클래스명.getInstance();
	
		// 이렇게 public메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한할 수 있다
	
	* 생성자가 private인 클래스는 다른클래스의 조상이 될 수 없다
		// 자손클래스의 인스턴스를 생성할 때 조상클래스의 생성자를 호출해야하는데 private이면 접근 할 수 없기 때문

# 4-6 제어자(modifier)의 조합
	1. 메서드에 static과 abstract를 함께 사용할 수 없다
		// static은 구현이 되어있는 메서드에만 사용 할 수 있고, abstract메서드는 구현하지 않은 메서드이기때문

	2. 클래스에 abstract와 final을 동시에 사용할 수 없다
		// abstract는 상속을 해서 완성시켜야하는 클래스 , final은 상속을 할 수 없는 클래스

	3. abstract메서드의 접근 제어자가 private일 수 없다
		// 메서드를 오버라이딩해야하기 때문

	4. 메서드에 private과 final을 같이 사용할 필요는 없다
		// 접근제어자가 private인 메서드는 오버라이딩 될 없기 때문에 둘중 하나만 사용해도 의미가 충분

============================================================================================

 [5. 다형성(polymorphism) ] ★★★★★★

# 5-1 다형성이란?
	* 조상 클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하는것
		// Parent p = new Child();
		
	* 인스턴스의 타입과 참조변수의 타입이 일치하는 것이 보통이지만 두개의 클래스가 서로 상속관계에 있을 경우 조상클래스
	  타입의 참조변수로 클래스의 인스턴스를 참조하도록 하는 것도 가능

	* 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
	* 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.

# 5-2 참조변수의 형변환
	* 서로 상속관계에 있는 클래스사이에서 자손타입 <-> 조상타입 형변환이 가능하다

	* 조상타입에서 자손타입으로 형변환시에는 캐스트연산자를 사용해야한다
		// Car c = new Truck();
		// Truck t = (Truck)c;

	* 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것이 아니다
		// 인스턴스의 주소값은 바뀌는것이 아니다

	* 참조변수의 형변환을 통해서 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것뿐이다

	* 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은
	  허용되지 않는다
		// ex)  Car c = new Car();
			Truck t = (Truck)c; -> 컴파일은 성공하지만 실행시 에러 발생
			 - c의 참조변수로 사용할 수 있는 멤버의 개수는 4개인데 t로 사용할 수 있는 멤버는 5개이기 때문에 불가능
		
# 5-3 instanceof 연산자
	* 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof연산자를 사용한다.
		// 주로 조건문에 사용

	* instanceof의 왼쪽에는 참조변수 / 오른쪽에는 타입(클래스명)이 피연산자로 위치한다
		// if(car instanceof Vehicle)

	* instanceof 연산자 사용이유
		// 조상타입의 참조변수로는 실제 인스턴스의 멤버들을 모두 사용할 수 없기 때문에, 실제 인스턴스와 같은 타입의 참조변수로
	 	   형변환을 해야만 인스턴스의 모든 멤버들을 사용할 수 있기 때문

	* 참조변수의 조상클래스의 instanceof연산자결과는 모두 true이다
		
	* instanceof연산의 결과가 true라는 것은 검사한 타입으로의 형변환을 해도 아무런 문제가 없다는 뜻
		// 검사한 타입으로 형변환이 가능

# 5-4 참조변수와 인스턴스의 연결
	* 자손,조상클래스에서 같은 이름의 멤버변수를 중복 정의한 경우?
		// 참조변수의 타입에 따라 사용되는 멤버변수가 다르다
		// 조상타입 참조변수 -> 조상클래스 멤버변수 사용
			- Parent p = new Child();
			- System.out.println(p.x); //100

		// 자손타입 참조변수 -> 자손클래스 멤버변수 사용
			- Child c = new Child();
			- System.out.println(c.x); //200f

# 5-5 매개변수의 다형성
	* 메서드의 매개변수에도 다형성이 적용된다
		// void method(Parent p){...};
			- Parent를 상속하고 있는 모든 Child클래스를 매개변수에 넣을 수 있다
			- ex) method(new Child1()),  method(c2);

	* 매개변수의 다형성을 이용한 예제 만들기

# 5-6 여러 종류의 객체를 배열로 다루기
	* 조상타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다
		// Parent p[] = new Parent[10]
		// p[0] = new Child1() .....

	* 컬렉션 프레임워크란?
		// 배열들을 편하게 관리하기 위해 만들어진 프레임워크

=======================================================================================================

 [6. 추상클래스(abstract class) ]

# 6-1 추상클래스란?
	* 미완성 설계도
		// 멤버의 개수에 관계된 것이 아니라, 추상메서드를 포함하고 있는 클래스

	* 추상클래스로 인스턴스를 생성할 수 없다.
		// 상속을 통해 자손클래스에서 추상메서드를 구현해야 자손클래스를 사용할 수 있다

	* 추상클래스를 사용하는 이유?
		// 서로 연관된 클래스를 만들때 공통부분이 담긴 미완성 설계도를 만들어 놓고,
		   이것을 이용하여 각각의 설계도를 완성하는 것이 효율적이기 때문

	* 추상클래스는 추상메서드를 포함하고 있는 것일 뿐이지 일반클래스와 전혀 다르지 않다
		// 생성자가 있고, 멤버변수와 메서드도 가질 수 있다

# 6-2 추상메서드(abstract method)
	* 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상 메서드이다
	
	* 추상메서드 사용이유?
		// 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 조상 클래스에서는 선언부만 작성하고
		   주석으로 어떤 기능을 수행하는지를 작성하면 상속받는 클래스에서 실제 내용을 구현하도록 비워두는 것이다

		// 추상클래스를 상속받는 자손 클래스는 조상의 추상메서드를 상황에 맞게 적절히 구현해주어야한다

		// 설계를 조금 더 편하게 하려고

	* 추상클래스 선언방법
		// /* 어떤 기능을 수행할 목적으로 작성하였는가를 설명 */
		   abstract 리턴타입 매개변수();
			- 선언부 맨앞에 abstract를 붙이고, 구현부 몸통({})를 작성하지 않는다.

	* 추상클래스로부터 상속받은 자손클래스는 오버라이딩을 통해 조상의 추상메서드를 모두 구현해주어야 한다
		// 구현하지 않으면 자손클래스도 추상클래스로 정의해야하고, 인스턴스로 만들 수 없다

# 6-3 추상클래스의 작성
	* 추상화는 기존의 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것
		// 반대로 구체화는 상속을 통해 클래스를 구현, 확장하는 작업

	* 빈 실행블럭을 만들어도 되는데 굳이 abstarct를 붙여 추상메서드로 만드는 이유?
		// 자손 클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서
			- 아무 내용없는 실행블럭을 가진 메서드를 상속받는다면 온전히 구현된 메서드로 인식하기 때문에 자신의 클래스에 
			  맞게 오버라이딩을 하지 않을 수 있기 때문

=======================================================================================================

 [ 7. 인터페이스(Interface) ]

# 7-1 인터페이스란?
	* 추상메서드 집합
	
	* 일종의 추상클래스
	
	* 추상클래스와 달리 몸통을 가진 일반메서드 또는 멤버변수(iv,cv)를 구성원으로 가질 수 없다

	* 구현된 것이 아무것도 없고 밑그림(선언부)만 그려져 있는 '기본 설계도'

	* 다른 클래스를 작성하는데 도움 줄 목적으로 작성된다

# 7-2 인터페이스 작성
	* 클래스를 작성하는것과 같지만 class대신 interface를 적는다
		// 클래스와 같이 접근제어자로 public 또는 default를 사용할 수 있다

	* 인터페이스 멤버들의 제약사항
		1. 모든 멤버변수는 public static final이어야 하며, 이를 생략할 수 있다
			// 인터페이스의 모든 멤버변수는 '상수' 이다

		2. 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다
		   (단, static 메서드와 디폴트 메서드는 예외)
			// 모든 메서드가 추상메서드이기 때문에 생략 가능

	* JDK1.8부터 인터페이스에 static메서드와 디폴트 메서드(default method)의 추가를 허용한다

# 7-3 인터페이스의 상속
	* 인터페이스는 인터페이스로부터만 상속 받을 수 있다
		// Object를 상속 받을 수 없다

	* 클래스와 달리 다중상속, 여려개의 인터페이스로부터 상속 받는것이 가능하다
		// class A implements Interface1, Interface2{...}
	
	* 클래스의 상속과 마찬가지로 자손 인터페이스는 조상인터페이스에 정의된 모든 멤버를 상속받는다.

# 7-4 인터페이스의 구현
	* 인터페이스에 정의된 추상메서드를 완성시켜줄 클래스를 작성해야한다
		// class A implements Interface1{...}

	* 인터페이스에 정의된 추상메서드를 모두 구현하지 않으면 추상클래스로 변경해야한다
		// abstract class A implements Interface1{...}

	* 상속과 구현을 동시에 할 수 있다
		// class A extends Parent implements Interface1{...}
			- 상위클래스, 인터페이스의 모든 멤버를 상속 받는다

	* 인터페이스는 상속 대신 구현이라는 용어를 사용하지만, 추상메서드를 구현하는 것이기 때문에 인터페이스도 조금은 다른 의미의 조상이라고
	  할 수 있다

	* 인터페이스에 작성된 추상클래스는 모두 public 접근제어자를 갖기 때문에 구현클래스에서 추상메서드를 오버라이딩 할 때 접근제어자는
	  모두 public 이어야 한다
		// 오버라이딩 할 때는 조상의 메서드보다 같거나 넓은 범위의 접근 제어자를 지정해야 한다.

# 7-5 인터페이스를 이용한 다중상속
	* 만약 두 조상으로부터 상속받는 멤버중 멤버변수의 이름이 같거나 메서드의 선언부가 일치하고 구현 내용이 다르다면 어느 조상의 것을
	  상속 받는지 알 수 없다

	* 인터페이스는 static상수만 정의할 수 있으므로 조상클래스의 멤버변수와 충돌하는 경우는 거의 없고 충동된다 하더라도 클래스 이름을
	  붙여서 구분이 가능하다

	* 인터페이스의 추상메서드는 구현내용이 전혀 없으므로 조상클래스의 메서드와 선언부가 일치하는 경우에는 당연히 조상 클래스 쪽의 메서드를
	  상속 받으면 되므로 문제가 되지 않는다
		// 두 조상의 메서드중 아무거나 상속받아도 상관없단 의미
			- 어차피 오버라이딩해서 구현해야 하기 때문

	* 자바에서 인터페이스로 다중상속을 구현하는 경우는 거의 없다.
		// 만일 두개의 클래스로부터 상속을 받아야 할 상황이라면, 비중이 높은 쪽을 상속받고 다른쪽은 클래스 내부 멤버로 포함시키는
		   방식으로 처리하거나, 어느 한쪽의 필요한 부분을 뽑아서 인터페이스로 만든 다음 구현한다

# 7-6 인터페이스를 이용한 다형성
	* 인터페이스를 구현한 클래스의 조상이라 할 수 있으므로 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조 할 수 
	  있으며, 인터페이스 타입으로의 형변환도 가능하다
		// 인터페이스타입의 참조변수로는 인터페이스에 정의된 멤버들만 호출이 가능하다
			- 실제 호출되는것은 인터페이스를 구현한 클래스의 멤버가 호출 된다

	* 인터페이스 타입의 매개변수가 갖는 의미는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다는 것이다
		
	* 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다

# 7-7 인터페이스의 장점
	1. 개발시간을 단축시킬 수 있다.
		// 인터페이스를 먼저 작성하면, 인터페이스를 구현한 클래스가 없어도 인터페이스를 이용하여 프로그램을 작성하는 것이 가능하다
		   동시에 다른쪽에서는 인터페이스를 구현하는 클래스를 작성하면 협업이 가능하여 동시에 개발을 진행할 수 있다		
			- 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면 되기 때문
	2. 표준화가 가능하다
		// 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 작성된 인터페이스를 구현하게 함으로써 
		   설계자가 원하는 표준대로 프로젝트를 만들 수 있다
			- 인터페이스를 작성할때 어떤것을 구현할지 주석으로 달아주어야 좋다

	3. 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
		// 아무런 관계가 없는 클래스들을 인터페이스를 구현하게 함으로써 공통된 인터페이스를 구현했다는 관계를 맺을 수 있다
			- 아무내용없는 인터페이스를 만들어서 구현만 해주면 된다
		
		// 기존의 관계를 유지하되 또다른 관계를 가지는 클래스들을 만들때 인터페이스를 사용할 수 있다

	4. 독립적인 프로그래밍이 가능하다(변경에 유리한 유연한 설계가 가능하다)
		// 클래스와 클래스간의 관계를 인터페이스를 이용하여 간접적인 관계로 변경하면, 의존성이 강한 관계에서 의존성이 약한 관계로
		   바뀌기 때문에 변경에 유리한 유연한 설계가 가능하다

# 7-8 인터페이스의 이해
	* 인터페이스를 이햏기 위한 두 가지 사항
		1. 클래스를 사용하는쪽(user)과 제공하는 쪽(provider)이 있다
	
		2. 메서드를 사용하는 쪽(user)에선 사용하려는 메서드(provider)의 선언부만 알면 된다(내용은 몰라도 됨)
			// user는 provider의 껍데기만 알면 된다
				- 클래스는 인터페이스에 선언된 추상메서드만 알면 사용에 아무 지장 없다

# 7-9 디폴트 메서드와 static메서드
	* JDK1.8부터 디폴트 메서드와 static메서드를 인터페이스에 추가할 수 있게 되었다

	1. static 메서드
		// 인터페이스에 종속적인 메서드
			- Interface.method()
			- 클래스의 static메서드를 사용하는 것과 같다

		// 접근제어자가 항상 public 이며 생략할 수 있다.
	
	2. 디폴트 메서드
		// 인터페이스를 중간에 부득이하게 변경해야 할 때 도움을 주는 메서드
			- 인터페이스를 작업 중간에 변경하려고 하면 추상메서드이기때문에 구현하는 클래스에서 변경이 필요하다
			  하지만 디폴트 메서드는 클래스에서 일반메서드와 같이 작업 내용이 있고 필요에 따라서 구현클래스에서 오버라이딩
			  하여 사용할 수 있다

		// 새로 추가된 디폴트 메ㅓ드가 기존의 메서드와 이름이 중복되는 경우 해결하는 규칙
			1. 여러 인터페이스의 디폴트 메서드 간의 충돌
				- 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
			2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
				- 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.

			* 규칙이 어렵다면 그냥 필요한 쪽의 메서드와 같은 내용으로 오버라이딩 하면 된다.

=======================================================================================================

 [ 8. 내부 클래스(inner class) ]
	* 내부 클래스는 클래스 내에 선언된다는 점을 제외하고 일반적인 클래스와 다르지 않다

	* 변수의 종류(인스턴스 변수, 클래스 변수, 지역 변수)와 마찬가지로 선언위치에 따라 유효범위와 성질이 유사하다
		// 비교해서 공부

# 8-1 내부 클래스란?
	* 클래스 내에 선언된 클래스
		// 클래스에 다른 클래스를 선언하는 이유?
			- 두 클래스가 서로 긴밀한 관계에 있기 때문에
			- 한 클래스에서만 사용되는 클래스를 감추기 위해

	* 내부 클래스의 장점
		// 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
			- 일반적으로 한 클래스에서 다른 클래스로 접근하려면 객체를 생성해주고 참조변수를 통해 접근해야 하지만,
			  내부 클래스에서는 객체 생성없이 외부클래스의 멤버에 접근이 가능하다

		// 코드의 복잡성을 줄일 수 있다(캡슐화)
			- 외부에는 불필요한 클래스를 내부 클래스로 만들어서 코드를 감추기 때문에 코드의 복잡성을 줄일 수 있다

	* 한 클래스를 제외하고는 다른 클래스에서 잘 사용되지 않는 클래스만 내부클래스로 만든다

# 8-2 내부 클래스의 종류와 특징
	* 인스턴스 내부 클래스 
		// 외부 클래스의 멤버변수 선언위치에 선언
		// 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언

	* 스태틱 내부 클래스
		// 외부 클래스의 멤버변수 선언위체에 선언
		// 주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언

	* 지역 내부 클래스
		// 외부 클래스의 메서드나 초기화블럭 안에 선언
		// 선언된 영역 내부에서만 사용될 수 있다
	
	* 익명 내부 클래스
		// 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용 클래스)

# 8-3 내부 클래스의 선언
	* 내부 클래스의 선언위치에 따라 같은 선언위치의 변수와 동일한 유효범위(scope)와 접근성을 갖는다
		// 인스턴스 변수, 클래스 변수, 지역 변수와 동일한 유효범위와 접근성

# 8-4 내부 클래스의 제어자와 접근성
	* 내부 클래스가 외부 클래스의 멤버와 같이 간주되고, 인스턴스멤버와 static멤버 간의 규칙이 내부 클래스에도 똑같이 적용됨
	
	* 내부 클래스는 멤버변수들 처럼 4개의 접근제어자 사용이 가능하다 

	* 외부 클래스가 아닌 다른 클래스에서 내부 클래스를 생성하고 내부 클래스의 멤버에 접근하려는 것은
	  내부 클래스로 선언해서는 안되는 클래스를 내부 클래스로 선언했다는 의미
		// 내부 클래스는 주로 외부클래스에서만 사용되는 클래스를 의미하기때문

# 8.5 익명 클래스(anonymous class)
	* 익명 클래스란?
		// 이름이 없는 클래스
		// 클래스의 선언과 객체의 생성을 동시에 하고, 오로지 하나의 객체만을 생성할 수 있는 일회용 클래스

	* 이름이 없기 때문에 생성자 X

	* 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다

	* 이름이 없는 클래스이기 때문에 클래스명은 '외부 클래스명$숫자.class'의 형식으로 클래스파일명이 결정된다