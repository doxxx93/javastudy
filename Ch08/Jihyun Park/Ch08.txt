Chap08. 예외처리(Exception Handling)

1. 프로그램 오류

컴파일 에러 - 컴파일 시에 발생하는 에러
런타임 에러 - 실행 시에 발생하는 에러
논리적 에러 - 실행은 되지만, 의도와 다르게 동작하는 것

Q. 컴파일을 성공적으로 마쳤다고 해서 오류가 없을까?
A. 아니다. 컴파일러는 소스코드의 기본적인 오류사항을 걸러주는 것이고, 실행 도중 발생할 수 있는 잠재적 오류는 찾아낼 수 없다. 따라서 컴파일을 잘 되었어도 실행중에 에러에 의해서 잘못된 결과를 얻거나 비정상적으로 종료될 수도 있다.
예) 실행 중 동작을 멈춘 상태로 오래 지속 / 갑자기 프로그램 종료

Q. 런타임 에러는 어떻게 방지할 수 있을까?
A. 프로그램 실행 도중 발생할 수 있는 모든 경우의 수를 고려하여 대비해야 한다.

런타임 에러
에러(error) : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
예외(exception) : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류


2. 예외 클래스의 계층구조

자바는 실행시 발생할 수 있는 오류(런타임에러:Exception과 Error)를 클래스로 정의하였다.
이미지 : 415페이지 2-8 상속계층도 / 크게 두 부분으로 나눠진다.

Exception클래스와 그 자손들(RuntimeException과 자손들 제외) [Exception클래스들]
주로 외부의 영향으로 발생 - 사용자들의 동작 등
예) 데이터 형식 입력 실수, 클래스 이름 실수

RuntimeException클래스와 그 자손들 [RuntimeException클래스들]
주로 프로그래머의 실수에 의해서 발생
예) 배열 범위 벗어남, null인 참조변수의 멤버호출, 클래스간 형변환 실수 등


3. 예외처리하기 - try - catch 구문

예외처리
정의 : 프로그램 실행 시 발생가능한 예외에 대한 코드를 작성하는 것
목적 : 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것

Q. 예외를 처리하지 못했을 경우?
A. 프로그램은 비정상적으로 종료되고, 처리하지 못한 예외는 JVM의 예외처리기가 받아서 예외의 원인을 화면에 출력한다.

예외처리를 위해서는 try-catch 구문을 사용하며, 그 구조는 다음과 같다.
try {
	// 예외 발생 가능성이 있는 문장을 넣는다.
} catch (Exception1 e1) {
	// Exception1이 발생할 경우, 이를 처리하기 위한 문장
} catch (Exception2 e2) {
	// Exception2이 발생할 경우, 이를 처리하기 위한 문장
} catch (ExceptionN eN) {
	// ExceptionN이 발생할 경우, 이를 처리하기 위한 문장
}

메서드 내에 try-catch문이 사용될 수 있고, 또 try블럭과 catch블럭 내에도 또 다른 try-catch문이 포함될 수 있다.

4. try - catch문에서의 흐름
예외가 발생한 경우와 아닌경우 문장실행순서가 다르다.
try블럭 내에서 예외가 발생한 경우
1. 발생한 예외와 일치하는 catch블럭이 있는지 확인한다.
2. 일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다. 만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.
try블럭 내에서 예외가 발생하지 않은 경우
1. catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속한다.

5. 예외의 발생과 catch 블럭
 catch블럭 : 괄호() + 블럭{}
괄호() 내에는 처리하고자 하는 예외와 ‘같은 타입의 참조변수’를 하나 선언해야 한다.
예외 발생시 어떤 일이 일어날까?
발생한 예외에 해당하는 클래스의 인스턴스 생성된다. → 첫번째 catch블럭부터 차례로 내려가며, catch블럭의 괄호() 내에 선언된 참조변수종류와 생성된 예외클래스의 인스턴스를 비교(instanceof 연산자를 이용) → 결과가 true인 catch블럭을 만나면 해당 블럭 내의 모든 문장을 수행하고, true인 문장을 만나지 못하면 예외는 처리되지 않는다.
모든 예외클래스는 Exception클래스의 자손이므로, 마지막 캐치블럭 괄호()에 Exception타입의 참조변수를 선언해놓으면 어떤 종류라도 이 catch블럭에 잡힌다.

printStackTrace()와 getMessage()
예외의 발생원인을 알 수 있다.  
예외발생시 생성되는 예외클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨있고, printStackTrace()와 getMessage()를 통해 정보 얻을 수있다.
printStackTrace() : 예외발생 당시의 호출스택(Call stack)에 있던 메서드 정보와 예외 메세지를 화면에 출력
getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메세지 얻기

멀티 catch블럭
 하나의 catch블럭으로 여러 예외를 처리하는 것
주로 코드 간단히 하는 수준으로 사용


6. 예외 발생시키기
1) 먼저 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든 다음
[Exception e = new Exception(“고의로 발생시켰음”);]
2) 키워드 throw를 이용해서 예외를 발생시킨다.
[throw e;]

RuntimeException 클래스들 : 컴파일러가 예외처리를 확인하지않음 / unchecked예외
Exception클래스들 : 컴파일러가 예외처리를 확인함 / checked예외


7. 메서드에 예외 선언하기
예외처리 방법
1. try-catch문(호출당한 쪽에서 직접 처리하기)
2. 예외 선언하기(떠넘기기, 알리기) - 호출한 쪽으로 예외 넘기기
3. 은폐(덮기, 무시하기)
4. 예외 되던지기(양쪽에서 처리)


메서드에 예외 선언 방법?
메서드 선언부에 키워드 throws 사용 (필수처리예외, checked예외만 적자)
예) void method() throws Exception1, Exception2, … {
// 이처럼 여러개 선언할 수 있다.
}


8. finally 블럭
예외 발생여부와 관계없이 수행되어야 하는 코드를 넣는다
try-catch 문의 맨 마지막에 위치해야 한다.

9. 자동 자원 반환 - try - with - resources문

10. 사용자정의 예외 만들기
프로그래머가 새로운 예외 클래스를 정의하여 사용
→ 조상은 Exception(사용자가 발생시킴), RuntimeException(프로그래머의 실수) 중에서 선택
메세지를 저장하려면 String을 매개변수로 받는 생성자 추가해야 함

11. 예외 되던지기(exception re-throwing)
예외를 처리한 후 다시 예외를 발생시키는 것 : 예외를 두 번 처리
예외를 양쪽에서 처리한다.

12. 연결된 예외(chained exception)
한 예외가 다른 예외를 발생시킬 수 있다.
예외 A가 B를 발생시키면, A는 B의 원인예외(cause exception)
“어떤 예외를 다른 예외로 감싼다”
사용 이유?
1. 여러 예외를 하나로 묶어서 다루기 위해서
2. checked예외를 unchecked예외로 변경하려 할 때
