==================================[ 8장 예외처리 (exception handling) ] ===================================

[ 1.1 프로그램 오류 ]
	* 프로그램 오류란?
		// 프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우, 이러한 결과를 초래하는 원인을
		   프로그램 에러 또는 오류라고 한다.

	* 프로그램 오류의 종류
		1. 컴파일 에러
			// 컴파일 할 때 발생하는 에러
				- IDE에서 에러를 쉽게 보여주기 때문에 수정이 매우 쉽다

		2. 런타임 에러 ★★★★★
			// 프로그램의 실행도중에 발생하는 에러
				- 컴파일된 바이트코드(.class)가 JVM에 의해 실행될때 발생하는 에러
				- 자바 코드 실행과정 간단히 설명

		3. 논리적 에러
			// 의도한 것과 다르게 동작하는 것
				- 코딩 실수

 # 1.1 -1 런타임 에러('에러'와 '예외')
	* 런타임 에러를 방지하기 위해 프로그램의 실행도중 발생할 수 있는 모든 경우의 수를 고려하여 이에 대한 대비를 해야한다
	
	* 자바에서는 실행 시(runtime) 발생할 수 있는 프로그램 오류를 '에러'와 '예외' 두가지로 구분한다
		// '에러'는 메모리 부족이나 스택오버플로우와 같이 일단 발생하면 복구할 수 없는 심각한 오류
			- 프로그램 코드에 의해서 수습될 수 없다

		// '예외'는 발생하더라도 수습될 수 있는 비교적 덜 심각한 것
			- 프로그램 코드에 의해서 수습될 수 있다

	* 예외는 발생하더라도 프로그래머가 이에 대한 적절한 코드를 미리 작성해 놓음으로써 프로그램의 비정상적인 종료를 막을 수 있다

-------------------------------------------------------------------------------------------------------

[ 1.2 예외 클래스의 계층구조 ]
	* 자바에서는 실행 시 발생할 수 있는 오류('에러','예외')를 클래스로 정의하였다

	* 모든 클래스의 조상은 Object이므로 Exception과 Error클래스도 Object의 자손이다

	* 모든 예외의 최고 조상클래스는 Exception 클래스이고 자손클래스들은 두 그룹으로 나눌 수 있다
		1. Exception 클래스와 그 자손들(RuntimeException 제외)
			// 프로그램 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외들
				- 존재하지 않는 파일이름을 입력(FileNotFoundException)
				- 클래스의 이름을 잘못 입력(ClassNotFoundException)
				- 입력한 데이터 형식이 잘못된경우(DataFormatException) 

		2. RuntimeException클래스와 그 자손들
			// 주로 프로그래머의 실수에 의해서 발생하는 예외들
				- 배열범위 벗어남(ArrayIndexOutOfBoundsException)
				- null을가진 참조변수를 통한 멤버호출(NullPointerException)
				- 클래스간의 형변환 에러(ClassCastException)

-------------------------------------------------------------------------------------------------------

[ 1.3 예외처리하기 try-catch문 ]
	* 실행도중 발생하는 에러는 어쩔 수 없지만, 예외는 프로그래머가 이에 대한 처리를 미리 해주어야 한다
	
	* 예외처리(Exception Handling)란?
		// 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것
			- try-catch, throws

	* 예외처리의 목적?
		// 예외의 발생으로 인한 실행 중인 프로그램의 갑작스런 비정상 종료를 막고, 정상적인 실행상태를 유지할 수 있도록 하는 것
			- 예외처리가 되지 않으면 프로그램은 비정상 종료되고, 처리되지 못한 예외(uncaught exception)는
			  JVM의 '예외처리기(UncaughtExceptionHandler)' 가 받아서 예외의 원인을 화면에 출력한다.

	* 예외 처리를 위한 try-catch문
		// 하나의 try블럭 다음에는 여려 종류의 예외를 처리할 수 있도록 하나 이상의 catch블럭이 올 수 있으며,
		   발생한 예외의 종류와 일치하는 단 한개의 catch블럭만 수행된다

		// 발생한 예외의 종류와 일치하는 catch블럭이 없으면 예외는 처리되지 않는다
			- 비정상 종료된다(Explain1_3.java)

	* try-catch블럭 안에 또 다른 try-catch문이 포함될 수 있다
		// catch블럭 내의 코드에서도 예외가 발생할 수 있기 때문
		
		// catch블럭 안에 또 다른 try-catch문을 작성할 때는 catch블럭의 참조변수 이름은 서로 달라야한다
			- catch는 한블럭이 하나의 메서드라고 생각하면, 하나의 메서드안에는 똑같은 지역변수를 만들수 없기 때문

-------------------------------------------------------------------------------------------------------

[ 1.4 try-catch문에서의 흐름 ]
	* 예외가 발생한 경우와 발생하지 않았을 때의 흐름
		1. 예외가 발생한 경우
			// 예외와 일치하는 catch문 확인, 있다면 catch문 실행후 try-catch빠져나감
			// 예외와 일치하는 catch문이 없다면 프로그램 강제 종료
			// Explain1_4_1

		2. 예외가 발생하지 않았을 경우
			// try문만 실행되고 try-catch문을 빠져나간다

-------------------------------------------------------------------------------------------------------

[ 1.5 예외의 발생과 catch블럭 ]
	* catch블럭은 괄호()와 블럭{} 두 부분으로 나뉜다

	* 예외가 발생하면, 발생한 예외에 해당하는 클래스의 인스턴스가 만들어진다
		
	* 예외가 발생한 문장이 try블럭에 포함되어 있다면, 이 예외를 처리할 수 있는 catch블럭이 있는지 찾게 된다.
		// 예외가 발생하면 instanceof연산자를 통해서 catch블럭들을 검사를해서 맞는 타입이 있다면 해당 catch블럭을 실행후 빠져나간다
			- 예외가 발생한 문장이 catch문을 실행하고 빠져나간다면 다른 catch블럭들은 실행되지 않는다
			- instanceof연산자를 통해 맞는 타입이 없으면 예외처리가 되지 않고 프로그램이 강제 종료된다
	
	* Exception클래스는 모든 예외의 조상이기 때문에 try블럭에서 어떠한 예외가 발생해도 모두 처리할 수 있는 클래스이다
		// 개발자가 생각하기에 발생할것 같은 예외들을 catch블럭에 명시하고 혹시모를 예외를 대비해 마지막에 Exception을 명시하면
		   어떠한 예외도 처리가 가능하다

 # 1.5-1 printStackTrace()와 getMessage() 
	* 예외가 발생했을 때 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨있다
	
	* getMessage()와 printStackTrace()를 통해 이 정보들을 얻을 수 있다
		// getMessage()
			- 예외클래스의 인스턴스에 저장된 메시지를 얻는다
		// printStackTrace()
			- 예외발생 당시의 호출스택에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다

	* try-catch문으로 예외처리를 하여 비정상 종료를 막는 동시에 printStackTrace메서드를 사용해서 어느 부분이 잘못되었는지 파악할 수 있다.

	* Explain1_5_1

 # 1.5-2 멀티 catch블럭
	* JDK1.7부터 여러 catch블럭을 '|' 기호를 이용해서 하나의 catch블럭으로 합칠 수 있게 되었다
		// 중복된 코드를 줄일 수 있다
		// 연결할 수 있는 예외 클래스의 개수에는 제한이 없다

	* 단점
		// 두 예외 클래스를 멀티 catch 블럭으로 작성했을때 두 예외 클래스는 상속관계가 아니어야 한다
			- 조상클래스만 있어도 예외처리가 가능하기 때문

		// 멀티 catch는 하나의 catch블럭으로 여러 예외를 처리하는 것이기 때문에 어떤 예외가 발생한 것인지 알 수 없다
			- Explain1_5_2

=======================================================================================================

[ 1.6 예외 발생시키기 ]
	* 예외 발생시키는 방법
		// 1. 예외 클래스의 객체를 만든다
			- Exception e = new Exception("예외발생");
				ㄴ 생성자에 String을 넣어주면 getMessage()를 이용해 얻을 수 있다

		// 2. 키워드 throw를 이용해서 예외를 발생시킨다
			- throw e;

		// throw new Exception("예외발생"); 위 두줄과 같다

	* 런타임에러의 종류
		1. unchecked예외
			// 컴파일러가 예외처리를 확인하지 않는 RuntimeException클래스들
				- 예외처리를 하지 않아도 실행에 문제 없음

		2. checked예외
			// 예외처리를 확인하는 Exception클래스들
				- 예외처리를 하지 않으면 실행시 강제 종료 

=======================================================================================================

[ 1.7 메서드에 예외 선언하기 ]
	* 예외를 처리하는 방법
		1. try-catch문 사용
		2. 예외를 메서드에 선언하기

	* 예외를 메서드에 선언하여 예외처리하기
		// 메서드의 선언부에 throws를 사용해서 메서드에서 발생할 수 있는 예외를 적어주면 된다
			- void method() throws Excepiton { ... }

	* Exception클래스를 메서드에 선언하면 모든 종류의 예외가 발생할 가능성이 있다는 뜻
		// 오버라이딩의 조건 다시 생각해보기
			1. 선언부가 같아야한다
			2. 좁은 접근제어자 X
			3. 조상클래스 메서드보다 많은 예외를 선언할 수 없다
				// Exception예외는 모든 종류의 예외를 내포하고 있기 때문에 가장 많은 예외를 가지고 있다

	* 예외가 발생한 메서드에서 예외처리를 하지 않고 자신을 호출한 메서드에게 예외를 넘겨줄 수는 있지만, 이것으로 예외가 처리된 것은
	  아니고 예외를 단순히 전달만 하는 것이다. 
		// 결국 어느 한 곳에서는 반드시 try-catch문으로 예외처리를 해주어야 한다.

=======================================================================================================

[ 1.8 finally 블럭 ]
	* finally 블럭은 예외의 발생여부에 상관없이 실행되어야할 코드를 포함시킬 목적으로 사용
		// try-catch-finally 의 순서로 구성

	* 예외가 발생한 경우
		// try -> catch -> finally

	* 예외가 발생하지 않은 경우
		// try -> finally

=======================================================================================================

[ 1.9 자동 자원 반환  try-with-resources문 ]
	* JDK1.7부터 try-with-resources문이라는 try-catch문의 변형이 새로 추가되었다
	
	* try-with-resources 사용이유?
		// 입출력에 사용되는 클래스 중에서 사용한 후에 꼭 닫아주어야 사용했던 자원이 반환되는 것들이 있는데 
		   finally문에서 close()를 하게 되면 다시 try catch를 사용해야 한다
			- 코드가 복잡해진다
			- try블럭과 finally문에서 모두 예외가 발생하면 try블럭의 예외는 무시된다

	* try-with-resources 사용방법
		// try문 ()괄호 안에 객체를 생성하는 문장을 넣으면 따로 close()를 호출하지 않아도 try블럭을 벗어나는 순간
		   자동적으로 close()가 호출 된 다음 catch블럭, finally 블럭이 수행 된다.

	* try-with-resources문에 의해 자동으로 객체의 close()가 호출될수 있으려면 try()괄호안에 있는 클래스가 
	  AutoCloseable이라는 인터페이스를 구현한 것이어야만 한다.

=======================================================================================================

[ 1.10 사용자정의 예외 만들기 ] 
	* 기존의 정의된 예외 클래스 외에 필요에 따라 프로그래머가 새로운 예외클래스를 정의하여 사용할 수 있다
		// 가능하면 새로운 예외 클래스를 만들기보다 기존의 예외클래스를 활용하는것이 좋다
	
	* 보통 Exception클래스, RuntimeException클래스로부터 상속받아 클래스를 만든다
		// class MyException extends Exception{...}

	* Explain1_10_1

=======================================================================================================

[ 1.11 예외 되던지기(exception re-throwing) ]
	* 예외를 처리한 후에 다시 에외를 발생시키는 것
	
	* 호출한 메서드와 호출된 메서드 양쪽 모두에서 예외처리하는 것
		// 예외를 두번 처리
			- 예외를 처리한후 인위적으로 다시 발생시키는 방법

=======================================================================================================

[ 1.12 연결된 예외(chained exception) ]
	* 한 예외가 다른 예외를 발생시킬 수도 있다.

	* 예외 A가 예외 B를 발생시켰다면, A를 B의 원인예외(cause exception)라고 한다

	* 원인 예외로 등록해서 다시 예외를 발생시키는이유?
		1. 여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위해서

		2. checked예외를 unchecked예외로 바꿀 수 있도록 하기 위해서

	* Explain1_12_1
		




	