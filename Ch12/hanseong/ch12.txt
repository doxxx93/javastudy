=========================================[ 12장 쓰레드 (thread) ]=========================================

[ 1.1 지네릭스(Generics)란? ]
	* 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능

	* 지네릭스의 장점
		1. 타입 안정성을 제공한다
			// 객체의 타입을 컴파일 시에 체크하기 때문

		2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해 진다.
	
	* 정리
		// 지네릭스는 다룰 객체의 타입을 미리 명시해줌으로써 번거로운 형변환을 줄여준다

=======================================================================================================

[ 1.2 지네릭 클래스의 선언 ]

[ 1.2-1 타입변수 ]
	* 타입변수는 '임의의 참조형 타입'을 의미한다
		// public class ArrayList<E> extends AbstractList<E>
			- <E> : 타입변수

	* 지네릭 클래스의 객체를 생성할 때는 참조변수와 생성자에 타입 T대신 사용될 실제 타입을 지정해주어야한다
		// ArrayList<Exercise> list = new ArrayList<Exercise>();

	* Explain1_2_1
		// 타입변수의 타입과 다른 클래스를 추가할 경우

	* 지네릭스가 도입되기 이전의 코드와 호환성을 유지하기 위해서 지네릭 클래스 임에도 지네릭스를 사용하지 않는것이 가능하지만
	  지네릭 클래스를 사용할 때는 반드시 타입을 지정해서 사용해야한다

[ 1.2-2 지네릭스의 용어 ] // ArrayList<String> list = new ArrayList<String>();
	1. 타입문자 E
		// public class ArrayList<E> extends AbstractList<E>
			- <E> 는 ArrayList의 타입변수 또는 타입 매개변수

	2. <String>
		// ArrayList<String> list = new ArrayList<String>();
			- 위에서 <String>은 지정된 타입이고 이것을 '매개변수화된 타입(parameterized)'라 한다(대입된 타입)

	3. ArrayList list = new ArrayList();
		// 위에서 지네릭클래스를 사용하지 않는 것을 원시타입(raw type)이라고 한다


	* ArrayList<String> , ArrayList<Integer> 는 서로 다른 타입을 대입하여 호출한 것일 뿐, 별개의 클래스를 의미하는 것은 아니다
		// 마치 매개변수의 값이 다른 메서드를 호출한것과 같다
			- add(3,5), add(2,4) 이 둘은 서로 다른 메서드를 호출한 것이 아니다

	* 컴파일 후에 ArrayList<String> , ArrayList<Integer> 이 둘은 이들의 원시타입으로 바뀐다
		// ArrayList로 바뀐다
			- 지네릭 타입이 제거된다는 의미

[ 1.2-3 지네릭스의 제한 ]
	1. static 멤버에 타입변수를 사용할 수 없다
		// 타입변수는 인스턴스변수로 간주되기 때문
			- static 멤버는 인스턴스변수를 참조할 수 없다

		// static멤버는 대입된 타입의 종류에 관계없이 동일한 것이어야 하기 때문
		
		// Explain1_2_2

	2. 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다.
		// new 연산자 때문, new연산자는 컴파일 시점에 타입 T가 뭔지 정확히 알아야 한다
			- instanceof연산자도 new연산자와 같은 이유로 타입변수를 피연산자로 사용할 수 없다

		// 지네릭 배열을 생성해야할 필요가 있을 때는?
			- new 연산자대신 'Reflection API'의 newInstance()와 같이 동적으로 객체를 생성하는 메서드로 배열을 생성하거나
			  Object배열을 생성해서 복사한 다음에 T[]로 형변환하는 방법 등을 사용한다

=======================================================================================================

[ 1.3 지네릭 클래스의 객체 생성과 사용 ]
	* Explain1_3_1

=======================================================================================================

[ 1.4 제한된 지네릭 클래스 ]
	* 타입 매개변수에 지정할 수 있는 타입의 종류를 제한할 수 있는 방법?
		// 지네릭 타입에 'extends'를 사용하면 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다
			- ex) MyClass<T extends Exercise> {...} // Exercise와 자식들만 타입으로 지정할 수 있음

	* 다형성에서 조상타입의 참조변수로 자손타입의 객체를 가리킬 수 있는 것처럼, 매개변수화된 타입의 자손 타입도 가능하다
		// ex)	MyClass<Exercise> my = new MyClass<>();
			my.add(new Climing());

	* 만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요할 경우에도 'extends'를 사용
		// implements X

	* 클래스와 인터페이스를 함께 구현해야 한다면 & 기호로 연결 하면 된다
		// MyClass<T extends Exercise & Injurable> {...}

	* Explain1_4_1

=======================================================================================================

[ 1.5 와일드 카드 ] ...어렵다
	* 하나의 참조 변수로 대입된 타입이 다른 객체를 참조 가능
		// ArrayList<?> list3 = new ArrayList<String>();
			- 와일드 카드 사용 없이는 생성자에 다른 타입의 객체가 올 수 없다
				! ArrayList<Object> list = new ArrayList<String>(); X

	* 객체 생성시 와일드 카드 사용
		// ArrayList<? extends Exercise> list = new ArrayList<Climing>();
		// list = new ArrayList<Surfing>();
		
	* 지네릭 타입만 다르게 메서드를 오버로딩 하면 에러(지네릭 메서드)
		// 지네릭 타입은 컴파일러가 컴파일할 때만 사용하고 제거해버리기 때문
		// Explain1_5_1

	* 메서드의 매개변수에 와일드 카드 사용
		// Explain1_5_2

=======================================================================================================

[ 1.6 지네릭 메서드 ] ...어렵다
	* 메서드의 선언부에 지네릭 타입이 선언된 메서드를 지네릭 메서드라 한다
		// 지네릭 타입의 선언 위치는 반환타입 바로 앞
			-ex) static <T> void sort(List<T> list, Comparator<? super T> c)
				! static멤버에는 타입 매개변수를 사용할 수 없지만, 메서드에 지네릭 타입을 선언하고 사용하는 것은 가능

	* 메서드를 호출할 때마다 타입을 대입해야 한다

	* 와일드카드를 쓸 수 없을때 지네릭 메서드 사용하는 경우가 많음

	* 지네릭 클래스에 정의된 타입 매개변수와 지네릭 메서드에 정의된 타입 매개변수는 전혀 별개의 것이다
		// 같은 타입문자를 사용해도 같은것이 아니다
			- 메서드의 타입 매개변수는 메서드 안에서만 사용가능

	* 지네릭 메서드는 지네릭 클래스가 아닌 클래서에도 정의될 수 있다

	* 지네릭 메서드와 와일드카드의 차이점
		// 지네릭 메서드는 메서드를 호출할 때마다 다른 지네릭 타입을 대입할 수 있게 한 것

		// 와일드 카드는 하나의 참조변수로 서로 다른 타입이 대입된 여러 지네릭 객체를 다루기 위한 것

=======================================================================================================

[ 1.7 지네릭 타입의 형변환 ]
	* 지네릭타입과 넌지네릭 타입간의 형변환은 항상 가능
		// 같은 클래스만

	* 대입된 타입이 다른 지네릭 타입 간에는 형변환 불가능
	
	* 와일드 카드가 사용된 지네릭 타입으로는 형변환 가능
		// 반대의 경우도 가능하지만 경고 발생
			- 와일드 카드는 확정된 타입이 아니므로 컴파일러는 미확정 타입으로 형변환하는 것이라고 경고한다.

=======================================================================================================

[ 1.8 지네릭 타입의 제거 ]
	* 컴파일러는 지네릭 타입을 제거하고, 필요한 곳에 형변환을 넣는다
		// 지네릭 클래스 안의 타입변수들이 지정한 클래스로 형변환 된다
		
		// 하위호환성을 위해서 지네릭 타입을 제거

	* 컴파일러의 지네릭 타입 제거 과정
		1. 지네릭 타입의 경계(bound)를 제거한다
			// 지네릭 타입이 알맞게 치환되고 클래스 옆의 선언은 제거된다
				- <T>인 경우는 T는 Object로 치환된다

		2. 지네릭 타입을 제거한 후에 타입이 일치하지 않으면, 형변환을 추가한다.
			// 지네릭 타입이 치환되면서 형변환이 필요한 소스에 자동으로 추가해 준다

=======================================================================================================

[ 2. 열거형 (enums) ]

[ 2.1 열거형이란? ]
	* 서로 관련된 상수를 편리하게 선언하기 위한 것
	
	* 상수의 값이 바뀌면 해당 상수를 참조하는 모든 소스를 다시 컴파일 해야하지만,
	  열거형 상수를 사용하면 기존의 소스를 다시 컴파일하지 않아도 된다

=======================================================================================================

[ 2.2 열거형의 정의와 사용 ]
	* 열거형을 정의하는 방법
		// 괄호 {}안에 상수의 이름을 나열
			- enum 열거형이름 { 상수명1, 상수명2 ...}

	* 열거형에 정의된 상수를 사용하는 방법
		// 열거형이름.상수명

	* 열거형 상수간의 비교방법
		// ==사용
			- equals()가 아닌 '=='로 비교가 가능한것은 그만큼 빠른 성능을 제공한다는 얘기
			- '<', '>'와같은 비교연산자는 사용 X
				! compareTo()로는 비교연산자 사용가능

	* switch문의 조건식에도 열거형 사용 가능
		// 주의할 점은 열거형이름.상수가 아니라 '상수'만 적어야 한다는 제약이 있다

[ 2.2-1 모든 열거형의 조상 - java.lang.Enum(열거형의 메서드) ]
	* values() : 열거형의 모든 상수를 배열에 담아 반환한다.
		// 모든 열거형이 가지고 있는 것으로 컴파일러가 자동으로 추가해 준다

	* ordinal() : java.lang.Enum클래스에 정의된 것으로, 열거형 상수가 정의된 순서(0부터 시작)를 정수로 반환한다

	* name() : 열거형 상수의 이름을 문자열로 반환한다

	* valueOf(String name) : 열거형 상수의 이름으로 문자열 상수에 대한 참조를 얻을 수 있게 해준다
		// 컴파일러가 자동으로 추가해주는 메서드

=======================================================================================================

[ 2.3 열거형에 멤버 추가하기 ]
	* 열거형 상수의 값이 불연속적인 경우?
	  ex) enum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10) }
		// 열거형 상수의 이름 옆에 원하는 값을 괄호()와 함께 적어준다

		// 지정된 값을 저장할 수 있는 인스턴스 변수와 생성자를 새로 추가 해준다
			- 주의할점, 먼저 열거형 상수를 모두 정의한다음 다른 멤버들을 추가해야한다 
			  ex) enum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10);
				...... }
		
		// 열거형의 인스턴스 변수는 반드시 final이어야 한다는 제약은 없지만, 열거형 상수를 저장하기 위한 것이므로 final을 붙여주자
		
	* 열거형의 생성자는 외부에서 호출이 불가능하다
		// 제어자가 묵시적으로 private이기 때문

	* 하나의 열거형 상수에 여러 값을 지정할 수도 있다
		// ex) enum Direction { EAST(1,<).....}
			- 인스턴스 변수와 생성자도 추가해야 한다

[ 2.3-1 열거형에 추상 메서드 추가하기 ]
	* 열거형에 추상 메서드를 선언하면 각 열거형 상수가 이 추상 메서드를 반드시 구현해야 한다
		// Explain2_3_1

	* 열거형에 추상 메서드를 선언할 일은 그리 많지 않으므로 가볍게 참고

=======================================================================================================

[ 3. 애너테이션(annotation) ]

[ 3.1 애너테이션이란? ]
	* 주석처럼 프로그래밍 언어에 영향을 미치지 않으며, 유용한 정보를 제공하는 것
		// 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 바로 애너테이션

	* JDK에서 제공하는 표준 애너테이션은 주로 컴파일러를 위한 것으로 컴파일러에게 유용한 정보를 제공한다

	* 새로운 애너테이션을 정의하기 위한 메타 애너테이션도 제공한다

=======================================================================================================

[ 3.2 표준 애너테이션 ]
	1. @Override
		// 메서드 앞에만 붙일 수 있는 애너테이션, 조상의 메서들르 오버라이딩하는 것이라는걸 컴파일러에게 알려주는 역할
	
		// 메서드 앞에 '@Override'라고 붙이면 컴파일러가 같은 이름의 메서드가 조상에 있는지 확인하고 없으면 에러메시지 출력

	2. @Deprecated
		// 더 이상 사용되지 않는 필드나 메서드에 '@Deprecated'를 붙인다
		
		// 다른 것으로 대체되었으니 더 이상 사용하지 않을 것을 권한다는 의미

		// 기존의 것 대신 새로 추가된 개선된 기능을 사용하도록 유도하는 것

		// '@Deprecated'가 붙은 대상을 사용하는 코드를 작성하면 컴파일할때 메시지가 나온다
			- 해당 소스파일이 'deprecated'된 대상을 사용하고 있으며, '-Xlint:deprecation'옵션을 붙여서 다시 
			  컴파일하면 자세한 내용을 알 수 있다는 메시지
				! deprecated된 대상일뿐 별다른 내용은 없다

	3. @FunctionalInterface
		// 함수형 인터페이스를 올바르게 선언했는지 확인하는 애너테이션
			- 잘못된 경우 에러를 발생시킨다
				! 함수형 인터페이스는 추상메서드가 하나뿐이어야 한다는 제약이 있다

	4. @SuppressWarnings
		// 컴파일러가 보여주는 경고메시지가 나타나지 않게 억제해준다
		
		// '@SuppressWarnings'로 억제할 수 있는 경고 메시지의 종류는 여러가지가 있다
			- 주로 사용되는 것은 'deprecated', 'unchecked', 'rawtypes', 'varargs' 정도

		// 사용법
			- @SuppressWarnings("deprecated")

			- @SuppressWarnings({"deprecated", "unchecked"})
				! 둘 이상의 경고를 동시에 억제하려면 괄호{}를 추가로 사용해야한다

	5. @SafeVarargs
		// 메서드에 선언된 가변인자의 타입이 non-reifiable타입일 경우 해당 메서드를 선언하는 부분과 호출하는 부분에서
		   "unchecked" 경고가 발생한다. 해당 코드에 문제가 없다면 이 경고를 억제하기 위해 '@SafeVarargs'를 사용

		// 이 애너테이션은 static이나 final이 붙은 메서드와 생성자에만 붙일 수 있다
			- 오버라이드 될 수 있는 메서드에는 사용할 수 없다는 뜻

		// non-reifiable?
			- 컴파일 후에 제거되는 타입
				! 지네릭 타입들은 대부분 컴파일 시에 제거되므로 non-reifiable타입이다
		
				! 컴파일 후에도 타입정보가 유지되면 reifiable타입

		// 메서드 앞에 '@SafeVarargs'를 붙이면 이 메서드의 가변인자는 타입 안정성이 있다고 컴파일러에게 알려 경고를 막는다
			- @SafeVarargs로 'unchecked'경고는 억제할 수 있지만, 'varargs'경고는 억제할 수 없기 때문에
			  습관적으로 @SafeVarargs와 @SuppressWarning("varargs")를 같이 붙인다

=======================================================================================================

[ 3.3 메타 애너테이션 ]
	* 메타 애너테이션은 애너테이션을 위한 애너테이션
		// 애너테이션에 붙이는 애너테이션으로 애너테이션을 정의할 때 애너테잇ㄴ의 적용대상(target)이나 유지기간(retention)등을
		   지정하는데 사용된다

	1. @Target
		// 애너테이션이 적용가능한 대상을 지정하는데 사용
			- ex) @Target({TYPE, FIELD, METHOD, PARAMETER, ....})

		// @Target으로 지정할 수 있는 애너테이션 적용대상의 종류
			- ANNOTATION_TYPE(애너테이션), CONSTRUCTOR(생성자), FIELD(필드(맴버변수,enum상수)),
			  LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE(타입(클래스,인터페이스,enum)),
			  TYPE_PARAMETER(타입 매개변수), TYPE_USE(타입이 사용되는 모든 곳)

	2. @Retention
		// 애너테이션이 유지 되는 기간을 지정하는데 사용
	
		// 애너테이션의 유지 정책(retention policy)의 종류
			1. SOURCE : 소스 파일에만 존재. 클래스파일에는 존재하지 않음
			2. CLASS  : 클래스 파일에 존재. 실행시에 사용불가. 기본값
			3. RUNTIME: 클래스 파일에 존재. 실행시 사용가능

		1. SOURCE
			// @Override, @SuppressWarning처럼 컴파일러가 사용하는 애너테이션은 유지 정책이 SOURCE이다

		2. RUNTIME
			// 실행 시에 '리플렉션(reflection)'을 통해 클래스 파일에 저장된 애너테이션의 정보를 읽어서 처리할 수 있다

		3. CLASS
			// 컴파일러가 애너테이션의 정보를 클래스 파일에 저장할 수 있게는 하지만, 클래스 파일이 JVM에 로딩될 때는
			   애너테이션의 정보가 무시되어 실행 시에 애너테이션에 대한 정보를 얻을 수 없다
				! 기본값임에도 불구하고 잘 사용되지 않는 이유

	3. @Documented
		// 애너테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 한다
			- 자바에서 제공하는 기본 애너테이션중에 Override, SuppressWarning을 제외하고는 모두 이 메타 애너테이션이 붙어 있다.

	4. @Inherited
		// 애너테이션이 자손 클래스에 상속되도록 한다.
			- @Inherited가 붙은 애너테이션을 조상클래스에 붙이면, 자손클래스도 이 애너테이션이 붙은 것과 같이 인식

	5. @Repeatable
		// 보통은 하나의 대상에 한 종류의 애너테이션을 붙이는데, @Repeatable이 붙은 애너테이션은 여러 번 붙일 수 있다
			- 같은 이름의 애너테이션이 여러 개가 하나의 대상에 적용될 수 있기 때문에, 이 애너테이션들을 하나로 묶어서
			  다룰 수 있는 애너테이션도 추가로 정의해야 한다

	6. @Native
		// 네이티브 메서드(native method)에 의해 참조되는 '상수 필드(constant field)'에 붙이는 애너테이션
	
		// 네이티브 메서드는 JVM이 설치된 OS의 메서드를 말한다 
			- 모든 클래스의 조상인 Object클래스의 메서드들은 대부분 네이티브 메서드
				! 네이티브 메서드는 자바로 정의되어 있기 때문에 호출하는 방법은 자바의 일반 메서드와 다르지 않지만
				  실제로 호출되는 것은 OS의 메서드 이다

=======================================================================================================

[ 3.4 애너테이션 타입 정의하기 ]
	* 새로운 애너테이션을 정의하는 방법
		// @interface 애너테이션이름 { 타입요소이름(); }

[ 3.4-1 애너테이션의 요소 ]
	* 애너테이션 내에 선언된 메서드를 '애너테이션의 요소(element)'라고 한다
		// 애너테이션의 요소는 반환값이 있고 매개변수는 없는 추상 메서드의 형태를 가지고, 상속을 통해 구현하지 않아도 된다
			- 다만 애너테이션을 적용할 때 이 요소들의 값을 빠짐없이 지정해주어야한다
	
		// 애너테이션의 각 요소는 기본값을 가질 수 있으며, 기본값이 있는 요소는 애너테이션을 적용할 때 값을 지정하지 않으면 기본값이 된다
			- @interface TestInfo{ in count() default 1; }

		// 애너테이션 요소가 오직 하나뿐이고 이름이 value인 경우, 애너테이션을 적용할 때 요소의 이름을 생략하고 값만 적어도 된다

		// 요소의 타입이 배열인 경우, 괄호{}를 사용해서 여러 개의 값을 지정할 수 있다

		// 기본값을 지정할 때도 마찬가지로 괄호{}를 사용할 수 있다

		// 요소의 타입이 배열일 때도 요소의 이름이 value이면 요소의 이름을 생략할 수 있다
			- @SuppressWarning의 경우 요소의 타입이 String배열이고 이름이 value여기 때문에 애너테이션을 적용할 때
			  요소의 이름을 생략할 수 있는것

[ 3.4-2 java.lang.annotion.Annotation ]
	* 모든 애너테이션의 조상은 Annotation이다.
		// 애너테이션은 상속이 허용되지 않으므로 Annotation을 조상으로 지정할 수 없다

	* 모든 애너테이션의 조상인 Annotation인터페이스에 equals(), hashCode(), toString()이 정의되어 있기 때문에
	  모든 애너테이션 객체에 대해 3개의 메서드를 호출하는 것이 가능하다

[ 3.4-3 마커 애너테이션 Marker Annotation ]
	* 값을 지정할 필요가 없는 경우, 애너테이션의 요소를 하나도 정의하지 않을 수 있다
		// 요소가 하나도 정의되지 않은 애너테이션을 마커 애너테이션이라 한다

[ 3.4-4 애너테이션 요소의 규칙 ]
 ! 애너테이션의 요소를 선언할 때 반드시 지켜야 하는 규칙
	* 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용된다

	* ()안에 매개변수를 선언할 수 없다

	* 예외를 선언할 수 없다

	* 요소를 타입 매개변수로 정의할 수 없다


	