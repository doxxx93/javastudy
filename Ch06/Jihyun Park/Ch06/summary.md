__[자바의 정석 3판] Ch06 01~03 : 업데이트중 ...__
=================================================


# 1. 객체지향 언어(OOP)

## 1-1 객체지향언어의 역사
* _Object-oriented Programming_
* __사물(객체) + 상호작용__
* 초창기에는 주로 과학실험이나 미사일 발사실험을 위함  
 → 모의 실험을 실제 세계와 유사하게 구현하고자 했고 객체지향이론이 적합
* “실제 세계는 사물(객체)로 이루어져 있다. 모든 사건은 사물간의 상호작용이다.”
* 결론적으로 프로그래밍 언어는 _현실세계에서의 일들을 편리하게 이루기 위해 사용하는 도구_ 이고, 모든 사물을 객체로 정의해서 프로그래밍에 이용하는 것이다.
* 상속, 캡슐화, 추상화 중심으로 구체적 발전

Q. 객체지향이란 무엇인가?

## 1.2 객체지향언어
* __재사용성 + 유지보수 + 중복코드제거__
* 코드의 재사용성이 높고 유지 및 보수가 용이하다
```
재사용성  - 새로운 코드를 작성할 때 기존 코드를 이용해서 쉽게 작성
관리의 용이성(유지보수) - 코드간의 관계를 이용해서 쉽게 코드 변경 가능
높은 신뢰성 - 제어자, 메소드를 이용해서 데이터를 보호하고 올바른 값 유지
```
* 각 사물(객체)은 각자 가진 속성(특징)이 있다. 해당 사물만의 특징을 잘 살려서, 응집력 있게 객체를 구성해야 한다.
* 만약 아무렇게나 객체의 속성 및 기능을 정의하면 해당 객체가 어디에 쓰일지, 어떻게 쓰일지 확실하지 않아 모든 게 꼬이게 될 것이다. (응집력이 없다.)

Q. 객체지향언어를 왜 사용할까? 특징과 관련지어 대답해보기

# 2. 클래스와 객체

## 2.1 클래스와 객체의 정의와 용도
* 클래스란?
  > 객체를 정의해놓은 것   
  > 객체의 설계도 또는 틀   
  > 객체를 생성하는 데 사용
* 객체란?
  > 실제로 존재하는 사물 또는 개념   
  > 각 객체마다의 기능과 속성에 따라 다양한 용도로 사용   
  > 유형/무형으로 존재
* __클래스는 단지 객체를 생성하는 데에 사용될 뿐 객체 그 자체는 아님__  
→ 원하는 기능의 객체를 사용하려면, 클래스를 이용해서 객체를 먼저 생성한 후 사용 가능
* __왜 클래스와 객체를 구분해야 할까?__   
→ 객체지향 언어는 재사용성이 높다고 했다. 그 이유는 클래스 하나로 _(설계도 하나로)_ 객체를 _(사물을)_ 원하는 만큼 만들어낼 수 있기 때문이다. 클래스를 한번 잘 만들어놓기만 하면 마치 설계도를 이용해 물건을 찍어내는 공장처럼 매번 어떻게 객체를 만들어낼지 고민하지 않고 찍어낼 수 있다.

Q. 클래스, 객체는 각각 무엇인가? 무엇이 다른가?

## 2.2 객체와 인스턴스
> 클래스로부터 객체를 만들어내는 과정을 “클래스의 인스턴스화” 라고 칭함
> 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.
> 객체와 인스턴스가 같은가?
→ 그렇다. 그러나 객체는 모든 인스턴스를 포괄하는 의미지만, 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미가 있다.
> 클래스 → [인스턴스화] → 인스턴스(객체)

Q. 객체와 인스턴스는 무엇이 다른가?

## 2.3 객체의 구성요소 - 속성과 기능
> 객체는 사물이라고 했다. 사물에게도 각 사물마다의 특징(속성)과 쓰임새(기능)이 있듯이 객체도 마찬가지로 속성과 기능이 있다.
> 객체 = 속성(상태가 어떤지) + 기능(뭘 할 수 있는지)의 집합으로 볼 수 있다.
> 속성 = 멤버변수, 특성, 필드, 상태 / 기능 = 메소드, 함수, 행위
> 클래스는 객체를 정의한 설계도 라고 했으므로, 클래스에는 객체의 모든 속성과 기능이 정의되어 있다.
> 예) TV객체
TV클래스로부터 TV객체를 만들어낸다.
속성에는 크기, 길이, 높이, 색, 볼륨, 채널 등
기능에는 켜기, 끄기, 볼륨높이기, 볼륨낮추기, 채널변경 등
String color;
boolean power;
int channel;
—---- 

Q. 객체의 구성요소 두가지에 대해 설명하고 예시를 들어보자.

## 2.4 인스턴스의 생성과 사용
> 인스턴스는 클래스로부터 만들어진다.
예) TV클래스를 이용해 TV인스턴스(객체) 만들기
먼저 TV인스턴스를 담을, TV그릇(변수)을 만든다.
TV인스턴스를 생성해서 만들어놓은 그릇에 담아 사용한다.
Tv t; // TV클래스 타입의 참조변수 t 선언
t = new Tv(); // Tv인스턴스 생성 후, 이 인스턴스의 주소를 t에 저장
> 항상 어떤 값이나 주소를 담으려면 그릇(변수)을 만들어야 한다.
> 기본타입 변수와 참조타입 변수 중, 인스턴스는 객체이므로 참조타입 변수에 주소가 저장된다.
> 인스턴스의 주소는 항상 해당하는 클래스 타입의 그릇(변수)에만 담을 수 있다.
> 인스턴스는 참조변수를 통해서만 다룰 수 있다. 인스턴스를 만들어 놓고서 담지 않으면 사용할 수 없다.
→ 자신을 참조하는 참조변수가 하나도 없는 인스턴스는 더 이상 사용될 수 X
→ 가비지 컬렉터에 의해 메모리에서 제거된다.
> 인스턴스 생성 시에 멤버변수는 각 자료형에 해당하는 기본값으로 초기화
> 참조변수에는 오직 하나의 주소값만 저장될 수 있다.

Q. 인스턴스의 생성 및 사용법과 참조변수를 연관지어 개념을 설명해 보자.

## 2.5 객체 배열
> 객체를 배열로 다룬다
> 많은 객체를 다룰 때 편리성을 위해 사용
> 객체는 참조변수에 담기므로, 객체배열에 객체가 직접 존재하지 않고, 주소가 저장된다.
> 타입만 지정한 객체 배열 생성 시 기본값은 null (참조변수의 기본값)
> 객체배열 생성법
Tv[] tvArr = new Tv[3]; // 타입만을 지정한 객체배열(기본값 null) 생성
Tv[] tvArr = {new Tv(), new Tv(), new Tv()}; // 3칸짜리 객체배열과 객체 3개를 동시에 생성 : 각 칸에는 생성시부터 각 객체 3개의 주소값이 담겨있다.

Q. 객체 배열이란 무엇인가?
Q. 객체 배열에 객체가 어떤 식으로 담기는지 설명해 보자.


## 2.6 클래스의 또 다른 정의
> 클래스는 객체의 설계도
> 프로그래밍적 관점에서 클래스
데이터와 함수의 결합 2. 사용자정의 타입
데이터와 함수의 결합
객체는 속성과 기능의 집합이라고 했다. 이 두 구성요소를 초기 프로그래밍 언어에서는 속성은 속성끼리[데이터], 기능은 기능끼리[함수] 다루어왔다. 하지만 자바와 같은 객체지향 언어에서는 속성(데이터)과 기능(함수)를 하나의 클래스에 정의하여 서로 관계된 것들끼리 동작하게끔 했다. 이 클래스로 인해 데이터와 함수들은 서로 유기적으로 연결되어 작업이 간단하고 명료해진다.
데이터 저장형태의 발전
변수 - 하나의 데이터를 저장할 수 있는 공간
배열 - 같은 종류의 데이터를 여러 개 저장할 수 있는 집합
구조체 - 종류에 관계없이 여러 데이터를 저장할 수 있는 집합
클래스 - 종류에 관계없는 여러 데이터와 함수까지 저장할 수 있는 집합
**표/그림 넣기**
사용자정의 타입(user-defined type)
사용자정의 타입은 프로그래머가 필요에 의해 서로 관련된 속성 및 기능을 뽑아 정의한다. 자바에서 기본형 타입은 8개지만, 참조타입은 무한으로 생성이 가능하다.
> 새로 정의하는 클래스가 곧 새로운 사용자정의 타입이 된다. 
> 예) 시간에 관련된 데이터를 세 가지 다룰 때
배열로 다루기
int[] hour = new int[3];
int[] minute = new int[3];
float[] second = new float[3];
// 같은 종류의 데이터끼리 시간은 시간, 분은 분, 초는 초끼리 나누어 저장
// 시, 분, 초가 서로 뒤섞일 수 있다.
// 다루어야 하는 데이터가 늘어나면 오류가 날 가능성도 매우 커진다.
클래스로 다루기
Time[] t = new Time[3];
t[0] = new Time();
t[1] = new Time();
t[3] = new Time();
// 각각의 시, 분, 초를 가지는 클래스를 3개 만들었다.
// 데이터가 꼬일 가능성이 매우 낮아졌으며, 클래스를 정의함으로 인해 필요한 기능(함수) 및 조건도 추가하여 사용할 수 있다.
// 필요한 조건 반영 예) 시, 분, 초는 모두 0보다 크거나 같다 / 시의 범위는 0~23, 초의 범위는 0~59
// 관련된 데이터 및 함수의 응집도가 높다.

Q. 클래스의 프로그래밍적 관점 두 가지를 서술하고 어떤 이점이 있는지 서술하자.

# 3. 변수와 메서드

## 3.1 선언위치에 따른 변수의 종류
> 변수는 선언된 위치에 따라 종류가 달라진다.
> 클래스변수, 인스턴스변수, 지역변수로 세 가지 종류가 있다.
> 멤버변수(클래스 영역에 선언된 변수) = 클래스변수 + 인스턴스변수
** 그림 + 표 첨부
인스턴스변수
> 인스턴스변수의 값을 읽거나, 저장하려면 먼저 인스턴스를 생성해야 한다.
> 인스턴스마다 고유한 상태를 유지해야 한다면 인스턴스 변수로 선언한다.
클래스변수
> 선언법은 인스턴수 변수 앞에 static만 붙이면 된다.
> 모든 인스턴스가 공유하는 변수다. 따라서 인스턴스가 생성될 때마다 다른 값이 아니므로, 인스턴스를 생성하지 않고도 바로 사용할 수 있다.
> 클래스가 메모리에 로딩될 때 생성 / 프로그램이 종료될 때 까지 유지
지역변수
> 메소드 내에 선언되어 오직 메소드 내에서만 사용 가능
> for문 또는 while문 블럭 내의 지역변수는, 해당 블럭을 벗어나서는 소멸하므로 사용할 수 없다.

Q. 인스턴스변수/클래스변수/지역변수의 차이점과 개념을 설명하자.


## 3.2 클래스변수와 인스턴스변수
> 하나의 클래스에서 나온 각 인스턴스들이 모두 공유해야 하는 속성은 클래스변수
→ 클래스변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 가진다.
> 하나의 클래스에서 나왔지만 각 인스턴스마다 다른 값을 가질 수 있다면 인스턴스변수
→ 인스턴스변수는 인스턴스를 생성할 때마다 새로 생성되므로 각기 다른 값을 가질 수 있다.
>  예) 카드
특징(속성/변수) : 무늬, 숫자, 폭, 높이 등..
모든 카드(인스턴스)가 공유해야 하는 속성 : 폭, 높이
모든 카드(인스턴스)마다 다른 값일 수 있는 속성 : 무늬, 숫자
** 그림 첨부 **
> 클래스변수는 인스턴스를 생성하지 않고도 사용할 수 있다. : [클래스이름.클래스변수]
> 클래스변수를 변경하면 모든 인스턴스에 적용이 된다.

Q. 클래스변수와 인스턴스변수의 공통점 및 차이점을 설명하자.

## 3.3 메서드
> 메서드는 프로그래밍에서 필요한 일련의 기능을 하나의 문단으로 정의해놓은 것이다.
> 메서드의 사용 이유
높은 재사용성
한 번 만들어놓은 메서드는 원하면 언제든지, 다른 프로그램에서도 사용 가능
중복된 코드의 제거
필요한 기능을 하나의 문단으로 만들어 정의해 놓았기 때문에, 해당 기능이 필요할 때마다 같은 코드를 반복해서 쓰지 않고 해당 메소드를 불러오기만 하면 된다.
기능 변경 시 메소드 문단만 변경하는 편리함
오류가 발생할 확률 또한 줄어든다.
프로그램의 구조화
작업단위로 나누어 해당 단위를 메소드에 담아 구조화
큰 규모의 프로그램일수록 효용가치 높음


## 3.4 메서드의 선언과 구현
> 메소드 = 선언부[header] + 구현부[body]
> 필요값, 반환값은 있을 수도 있고 없을 수도 있다.
> 선언부[header]
메소드 이름 / 매개변수 선언 / 반환타입
작업 수행을 위해 필요한 값, 결과로 나갈 값의 타입 등을 정의한다.
> 구현부[body]
메소드 고유의 기능
> 예) int add (int x, int y) { // 메소드 이름, 반환값은 int, 필요값은 int타입의 값 2개
int result = x + y; // 구현내용
return result;} // return을 통해 반환값을 내보내준다.


## 3.5 메서드의 호출
** 사진 **

> 인자(argument)와 매개변수(parameter)
메소드 호출시 괄호()안에 지정해준 값들을 인자 또는 인수라고 한다.
인자의 개수와 순서는 반드시 메소드 선언부에 선언된 매개변수와 일치해야 한다.
> 메소드의 실행흐름
같은 클래스 내의 메소드끼리는 참조변수를 사용하지 않고도 서로 호출 가능
단, static메소드는 같은 클래스 내의 인스턴스 메소드를 호출할 수 없다.
메소드가 호출되면, 지금까지 실행 중이던 메소드는 실행을 잠시 멈추고 호출된 메소드의 문장들이 실행된다.
메소드는 호출 시 넘겨받은 값으로 연산을 수행하고, 그 결과를 반환하며 종료된다.

## 3.6 return 문
> return문은 현재 실행중인 메소드를 종료하고 호출한 메소드로 돌아간다.
> 모든 메소드는 반환값의 유무에 관계없이 적어도 하나의 return문이 있어야 한다.
> 반환타입이 void (반환값이 없을 때) 일 때, return문이 없으면 컴파일러가 자동으로 메소드의 마지막에 return;을 추가해준다.

## 3.7 JVM의 메모리 구조
> 응용프로그램 실행 → JVM은 메모리를 할당받음 → 이 메모리를 나누어 관리
> ** 사진 **
1. 메소드 영역(method area)
프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽고 분석하여 클래스 데이터를 메소드영역에 저장한다. 그 클래스의 클래스변수도 함께 생성된다.
2. 힙 영역(heap area)
프로그램 실행 중 생성되는 인스턴스는 모두 이 곳에 생성된다. 인스턴스 변수도 이 곳에 생성된다.
3. 호출스택(call stack / execution stack)
호출스택은 메소드의 작업에 필요한 메모리 공간을 제공한다. 메소드의 실행 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장한다. 메소드가 작업을 마치면 할당된 공간은 반환되어 비워진다.
> 메소드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
> 메소드가 수행을 마치고 나면 사용했던 메모리를 반환하고 스택에서 제거된다.
> 호출스택의 제일 위에 있는 메소드가 현재 실행 중인 메소드이다.
> 아래에 있는 메소드가 바로 위의 메소드를 호출한 메소드이다.
> 객체를 생성하지 않고도 메소드를 호출할 수 있으려면, 메소드 앞에 static을 붙이면 된다.


## 3.8 기본형 매개변수와 참조형 매개변수
> 자바에서는 메소드를 호출할 때 매개변수로 지정한 값을 메소드의 매개변수에 복사하여 넘겨준다.
> 매개변수의 타입이 기본형일 때는 기본형 값이 복사된다.
변수의 값을 읽기만 가능
> 매개변수의 타입이 참조형일 때는 인스턴스의 주소가 복사된다.
주소를 통해 인스턴스 자체에 접근하기 때문에 변수의 값을 읽고 변경할 수 있다.
> 매개변수의 타입이 배열이면, 참조형 매개변수이다.
> 참조형 매개변수를 활용하면, 반환값이 없는 메소드여도 메소드의 실행결과를 얻어올 수 있다.

## 3.9 참조형 반환타입
> 모든 참조형 타입의 값은 ‘객체의 주소’이다.
> 객체를 생성한 후 참조형 변수에 담아놓지 않으면 사용할 수 없다.
> ‘반환타입이 참조형’이라는 것은 메소드가 ‘객체의 주소’를 반환한다는 것을 의미한다.


## 3.10 재귀호출(recursive call)
> 메소드 입장에서는 자기가 자신을 호출하는 것과 다른 메소드를 호출하는 것에 차이가 없다.
> ‘메소드 호출’은 그저 특정 위치에 저장되어 있는 명령을 수행하는 것이다.
> 재귀호출은 조건문이 필수로 따라다닌다.
> 재귀메소드 작성시 매개변수의 유효성 검사가 중요하다.
> main메소드 또한 자기 자신을 호출할 수 있다.
> 메소드가 종료되지 않고 계속 호출스택에 쌓이게 되면, 호출스택의 메모리 한계를 넘기는 StackOverflowError가 발생하여 프로그램은 비정상적으로 종료된다.


## 3.11 클래스 매서드(static 메서드)와 인스턴스 메서드
> 메소드 앞에 static이 붙으면 클래스 메소드, 없으면 인스턴스 메소드
> 인스턴스와 관계 없는 [인스턴스 변수나 인스턴스 메소드를 사용하지 않는] 메소드를 클래스 메소드로 정의한다.
> 클래스 영역에 선언된 멤버변수(클래스변수+인스턴스변수) 중, 모든 인스턴스에 공통된 값을 유지해야하는 것이 있다면 static을 붙인다.
> 클래스 메소드
객체를 생성하지 않고도 호출 가능
‘클래스이름.메소드이름(매개변수)’ 형식
인스턴스 변수를 절대 사용할 수 없다.
> 인스턴스 메소드
메소드 작업을 수행하는 데에 인스턴스 변수가 필요한 메소드
인스턴스 변수는 객체 생성해야 만들어지므로, 인스턴스 메소드도 반드시 객체를 생성한 후 호출 가능

## 3.12 클래스 멤버와 인스턴스 멤버간의 참조와 호출
> 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 및 호출 가능
> 단, 클래스멤버가 인스턴스멤버를 참조 및 호출할 경우 인스턴스를 생성해야 한다.
→ 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문

오버로딩
오버로딩이란?
오버로딩의 조건
오버로딩의 예
오버로딩의 장점
가변인자(varargs)와 오버로딩
생성자
생성자란?
기본 생성자(default constructor)
매개변수가 있는 생성자
생성자에서 다른 생성자 호출하기 - this(), this
생성자를 이용한 인스턴스의 복사
변수의 초기화
변수의 초기화
명시적 초기화
초기화 블럭
멤버변수의 초기화 시기와 순서
