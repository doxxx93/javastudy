## 객체지향 프로그래밍1

## 주의

- 하나의 소스 파일에 여러 클래스 작성- 원래는 하나의 소스 파일에 하나의 클래스를 작성하는 것이 국룰이나... **여러 개**도 가능
    1. 규칙 1. **public이 붙은 클래스(아니면 public 메서드가 포함된 클래스)는 하나만** 있어야하고, 소스파일의 이름(Hello2.java 같은)과 public 클래스의 이름이 같아야한다. 그렇지 않다면 함수를 호출해도 제대로 호출이 안된다. 만약 그래도 실행하고 싶다면  run figuration 에서 해당 메소드를 찾아서 실행한다. (원래는 소스파일의 이름과 같은 메서드로 자동 설정된다)
    2. 규칙 2. public이 없다면 소스파일의 이름은 클래스의 이름 중 하나면 된다. 
    3. 규칙 3. 파일이름 대소문자 구분해야한다.
- 객체를 만드는 클래스와 실행하는 클래스 분리
- 속성과 메서드를 포함한 클래스, 그리고 iv와 cv를 포함한 클래스가 나중에 작성되어있다===> **JVM이 먼저 static 부분을 메모리에 올리고 그 다음에 Class들을 올리고 Main 메서드를 수행**하는 것으로 알고 있습니다. 이는 자바는 객체지향이기에 앞뒤 선언 상관 없다.
- 연습을 여러 번 해서 그림 안 보고 코드만 보고 저처럼 단계별로 스택 그림을 그릴 수 있어야! ## 플래쉬 동영상 꼭 보기
- 같은 클래스 내에서 선언된 메서드를 같은 클래스 내에서 호출할 때는 클래스이름.메서드이름이 아니라 메서드 이름만!!
- 인스턴스 멤버(메서드, 변수)를 사용하기위해 객채 생성 팁

```java
MemeberCall c = new MemberCall(); 
int result = c.instanceMethod1();

// 를 다음과 같이 한 줄로 할 수 있다.

int result = new MemberCall().instanceMethod1();

// 대신 참조변수를 선언하지않아기에 생성된 MemberCall 인스턴스는 더 이상 사용 불가!
```

## 1.1 객체지향 언어

- **설계**와 관련된 언어이다. **객체는 속성만 갖고 있는게 아니라 기능을 가질 수도!**
- **코드의 재사용성이 높고,유지보수 용이, 중복 코드 제거 ⇒ 이를 중점으로 학습!**
- 서로 관련된 값들을 묶을 수 있다는 장점. 또한, 제어자와 메서드를 이용해서 데이터 보호 및 올바른 값 유지.

```java
ex) class Time {
		int hour; int minute; int second;
		} 
// int 타입 빈 상자 3개를 갖고 있는 Time이라는 객체 생성하게끔 하는 설계도
// 객체 그 자체는 아니다. 즉, 객체를 만들어야 사용 가능하다. 

		Time t = new Time(); 
// Time t 라는 빈 상자(객체 주소값 있다)를 만들고, 이는 객체를 가리키는 리모컨이 된다. 그래서 자연스럽게 int 타입 빈 상자 3개도 사용하게 된다.
		t.hour =12;
		t.minut = 34;
		t.second = 56;
```

- 객체지향 언어= 프로그래밍 언어+ 객체지향 개념(규칙)

-> **규칙 외우기(외우지 않으면 에러가 나와도 무슨 말인지 모른다. 이해 못해도 일단은 외우기부터.  요약하고 깜지로 공부할것**)

- ## 깃허브에서 자바의정석 마스터 예제 다운받기!!
    
    여기 플래쉬를 보면서 콘솔과 메모리가 어떻게 변하는지 볼 수 있다. 나중에 코드를 보면서 메모리 그림을 그릴 줄 알아야!!
    
    - 핵심개념 1. 캡슐화 2. 상속 3. 추상화  4. 다형성(가장 중요)
    - 공부법: 6장 2-3번 반복. 7장은 다형성까지만 반복 공부하고, 추상화. 인터페이스는 다형성 이해 후 공부할 것. ⇒ 중요한 것은 얼른 만들어보는 것이 중요. 객체지향을 마스터하면 디자인패턴 등의 이론서 혹은 JSP, Spring 등의 실습.

## 2. 클래스와 객체

- **클래스**: 객체를 정의한 것. 객체를 생성하는데 사용하는 설계도

// JDK에서는 프로그래밍을 위해 많은 수의 유용한 클래스(Java API)를 기본 제공

ex)  붕어빵 기계**객체**: 실제로 존재하는 것. 사물 또는 개념. 객체가 가지고 있는 기능과 속성에 따라 다르다. 객체를 사용하기위해 필요(이는 객체가 가진 속성과 메서드를 활용한다는 뜻) ex) 제품, 붕어빵

![// void power() 는 매개변수 없고, power를 게속 !power로 정의하면서 Tv를 킬 때는, power = false; 인데, !power가 true 여서 이를 power 속성에 저장하고 tv를 키게 되는 것. 끌 때는 그 반대.](https://blog.kakaocdn.net/dn/Y6Yzz/btrc2o9lan1/GJTpoRo0MAXGYefOnbjCF1/img.png)

// void power() 는 매개변수 없고, power를 게속 !power로 정의하면서 Tv를 킬 때는, power = false; 인데, !power가 true 여서 이를 power 속성에 저장하고 tv를 키게 되는 것. 끌 때는 그 반대.

## 2.2 객체와 인스턴스

 - 객체: 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.

 - 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화, 이렇게 만들어진 객체를 클래스의 인스턴스라고 한다. 

 - 객체는 모든 인스턴스를 대표하는 포괄적 의미, 인스턴스는 보다 구체적인 의미

ex) 책상은 객체다. 그리고 책상은 책상 클래스의 인스턴스다. 

- 객체의 구성요소: 속성과 기능

- 예를 들어, TV라는 객체가 있다면 **객체 = 속성(변수) + 기능(메서드)**로 나누면 된다고 생각했다.  즉, 객체는 속성과 기능의 **집합**. 속성과 기능은 해당 객체의 **멤버**다.

```java
ex) class tv{
        String color; //색깔
        boolean power; //전원상태
        int channel; //채널   ----- 속성(변수) = 멤버변수 // 또한, 자료형
										 //이 때, 멤버션수들은 자료형에 맞게 기본값으로 **초기화**

        void power() {power= !power;} // 이를 통해 굳이 if문 사용x
        void channedUp() { channel++;}
                                   -----기능(메서드)
```

이렇게 속성과 메서드를 만들면 하나의 클래스가 만들어진다. = 설계도

![https://blog.kakaocdn.net/dn/bflR8m/btrc6QYkFrO/eld9F9kMIEXWfYoyTFPpM1/img.png](https://blog.kakaocdn.net/dn/bflR8m/btrc6QYkFrO/eld9F9kMIEXWfYoyTFPpM1/img.png)

## 2.4 객체의 생성과 사용 (클래스[설계도] 작성), 객체배열

### **1. 객체의 생성**

- 클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언 

 - 인스턴스는 참조변수를 통해서만 다룰 수 있고, 참조변수와 인스턴스의 타입은 =   

ex)

```java
Tv t= new Tv(); 
// TV 클래스 타입의 참조변수 t 선언과 Tv 인스턴스를 생성
// **Tv t 는 아직 아무런 값도 없는 빈 상자이기에 메모리 주소도 없다.** 
// 생성된 Tv인스턴스의 주소를 참조변수 t에 저장
// (오른쪽부터 읽어나가자)==>> 이 부분 되게 중요!!
```

- Tv t;  의 의미
    
    //  t 변수를 선언한 순간, TV클래스의 객체(기능과 메서드)가 메모리에 만들어진다. 참조변수를 선언하는 건이 곧 리모컨과 같은데, 이것이 없다면 객체를 사용할 수 없다. 쉽게 말해서, Tv t를 선언한 순간, Tv 타입에 맞는 리모컨이 만들어지고, new Tv()로 Tv인스턴스를 생성한 후, 이를 사용하기위해 알맞는 타입의 리모컨 t로 연결한다고 생각하자.
    

![t 변수 선언과 TV인스턴스 생성되고나서 어떤 형태로 연결되는지](https://blog.kakaocdn.net/dn/bkwmUE/btrcVjuNSOI/7pm6DLFdcQSEMuZLb5ePy1/img.png)

t 변수 선언과 TV인스턴스 생성되고나서 어떤 형태로 연결되는지

### **2. 객체의 사용**

ex) t1.channel = 7; 인 경우, Tv t1과 Tv t2의 .channel 은 이름만 같지, 다른 변수이다.

- 객체의 생성과 사용

 - Tv2 객체 사용 불가. 사용할 수 없는 객체는 가비지 컬렉터(청소부)로 간다.

 - 하나의 인스턴스를 여러 개의 참조변수가 가리키는 것은 가능하나, 여러 인스턴스를 하나의 참조변수가 가리킬 수 없다.  

![https://blog.kakaocdn.net/dn/tGJq0/btrcUllSVnE/9ewE0tvDh8ViVJtehX8Ka1/img.png](https://blog.kakaocdn.net/dn/tGJq0/btrcUllSVnE/9ewE0tvDh8ViVJtehX8Ka1/img.png)

Tv2 객체 사용 불가

<aside>
🔥 Tv타입 객체를 참조한 t1, t2이 있는데, t2 = t1; 을 하게 되면 t2 리모컨이 t1 리모컨과 같아져, t1리모컨이 가리키는 객체를 참조하게 된다.

</aside>

- 과정
    
    ![https://blog.kakaocdn.net/dn/tGJq0/btrcUllSVnE/9ewE0tvDh8ViVJtehX8Ka1/img.png](https://blog.kakaocdn.net/dn/tGJq0/btrcUllSVnE/9ewE0tvDh8ViVJtehX8Ka1/img.png)
    

## 2.5 객체 배열

// 많은 수의 객체를 다뤄야할 떄, 배열로 다루면 편리. 

// 객체 배열 안에 객체의 주소 저장. 즉, 참조변수들을 하나로 묶은 배열이다.

- 객체 배열 === 참조변수 배열

```java
Tv tv1, tv2, tv3;  ---> Tv[] tvArr =new Tv[3]; 
//길이가 3인 Tv타입의 참조변수 배열
// tvArr[0] = new Tv(); //tvArr[1] ....... 처럼 
객체를 생성해서 배열의 각 요소에 저장하는 것이다. 

=== Tv[] tvArr = { new Tv(), new Tv(), new Tv() }; 와 같다.

```

- 객체 배열의 초기화
    

    
    //참조 변수 3개를 배열로 만든 것과 같다고 하여 객체배열을 참조변수 배열
    //그렇기 때문에 참조변수 배열을 만들고나서, 
    //참조변수를 채워줘야 제대로 작동한다. 즉, 객체를 생성해서 각 요소에 저장해야!
    //Tv[] tvArr = new Tv[3]; 만 작성하지말라! ⇒ tvArr[0] = new Tv();... 도 해야한다.
    
    ⇒ 이를 한 줄로 줄이면, Tv [] tvArr = {new Tv(), new Tv(), new Tv()}; 
    

- 다뤄야할 객체의 수가 많으면 for문 활용

```java
Tv [] tvArr = new Tv[100];

for (int i=0; i<tvArr.length; i++){
		tvArr[i] = new Tv();
}

// tvArr.length를 잘 활용할 것!
```

- 일반 객체와 객체 배열의 차이. tvArr에 3칸
    
    ![https://blog.kakaocdn.net/dn/bhDnF6/btrcVjuMMHQ/LdqikmNxF7UOMai8e914WK/img.png](https://blog.kakaocdn.net/dn/bhDnF6/btrcVjuMMHQ/LdqikmNxF7UOMai8e914WK/img.png)
    

## 2.6 클래스의 정의

// 설계도는 객체지향이론의 관점에서의 정의이다.

- 프로그래밍 관점에서의 정의
    
    ![https://blog.kakaocdn.net/dn/b2bY0c/btrcORyiAxg/hkKHxs0deOKr6ITMFTCR71/img.png](https://blog.kakaocdn.net/dn/b2bY0c/btrcORyiAxg/hkKHxs0deOKr6ITMFTCR71/img.png)
    

 -  클래스 == 데이터 + 함수

 - 구조체: 배열은 같은 종류의 데이터밖에 못 다루나, 구조체는 서로 관련된 여러 데이터(종류 상관x) 를 하나로 저장한다. 데이터가 곧 변수. 

  - 클래스: 데이터를 다루지않는 경우도 있지만, **변수(데이터)를 다루는 함수(메서드)와 묶어** 작업 계산하기위한 묶음이다. (데이터와 함수가 서로 관련있다고 할 수 있다)

- 클래스는 사용자 정의 타입: 기본형 외 원하는 타입을 직접 만들 수 있다.

- 여러 데이터에 있는 시간과 분, 초를 다루기 위해 배열을 사용하는 경우, 시간끼리 묶이기 문제 때문에하나의 클래스로 시간과 분, 초를 묶는다.

```
ex) class Time{
     int hour;
     int minute;
     float second;
}
Time t = new Time();

// 관련 변수의 타입이 서로 다르거나 하는 이유 때문에 뒤섞여서 올바르지않은 데이터가 될 수 있다. 그래서 

```

- 객체지향코드vs비객체지향코드
    
    
    

## 3. 변수와 메서드

## 3.1 선언 위치에 따른 변수의 종류


- **클래스 영역에서 static이 붙은 cv**(=static 변수, 모든 인스턴스에 공유되는 변수)

 - iv와 달리, 인스턴스 생성없이도 언제라도 바로 사용 가능. public이 붙으면 전역변수가 된다. (전역변수 = 같은 프로그램 내에서 어디서나 접근 가능 변수)

- ex)
    
    ```java
    class Variables{// 클래스 시작
         int iv; // 인스턴스 변수(클래스 전체에서 사용가능), 
    						//인스턴스가 생성될 때 생성된다. 
    ex) class Time{ int hour; int minute; int second;}  
    //일 때, hour, minute, second 다 iv에 해당한다. 
    //객체는 iv를 묶어놓은 것이라고 생각하면 이해하기 쉽다.  
         static int cv; 
    // 클래스 변수 (클래스 전체에서 사용가능), 클래스이름.클래스 변수 가능
    //클래스가 메모리에 올라갈 때 생성된다. 
    // (=객체를 만들기 전 설계도 시기) 하드에 저장된 파일을 읽기위해 
    // RAM(메모리)에 올리는 시기. 그래야 CPU에서 읽을 수 있다.
    // (RAM하고만 일할 수 있다) cv는 iv와 달리, 객체 생성이 따로 필요 없다. 
    // 선언문만 가능. y=x+3; sop; 같은 문장은 못들어온다.  
         void method()
    { // 메서드 시작
         int lv=0; 
    //지역변수. 이 지역변수는 메서드 영역에서만 유효(메서드 종료시 자동제거),
    // 변수 선언문이 수행될 때 생성된다.         
    } ---메서드 끝
    }-- 클래스 끝
    ```
    

## 3.2 클래스 변수와 인스턴스 변수

<aside>
🔥 **객체는 iv를 묶어놓은 것**

</aside>

<aside>
🔥 중요!! iv는 객체마다 만들어지지만, cv는 별도의 공간에 1개만 만들어지기에 메모리 절약을 한다.

</aside>

- cv와 iv의 차이

 - iv: 개별속성(객체마다 다르게 유지되어야하는 값(속성))

 - cv: 공통 속성(모든 객체가 공통적으로 갖는 값(속성)) 

// 모든 인스턴스가 같은 저장공간을 참조하는 것이다. 그러니, **클래스변수.cv**

⇒ 각 인스턴스 이름.cv 를 사용해도 상관없지만 iv로 오해할 수도....

=> iv와 cv를 포함한 클래스 생성하고나서 **이를 활용하려면,** 객체를 생성한다.

- 그림으로 보는 cv와 iv의 차이
    
    ![https://blog.kakaocdn.net/dn/QhzTY/btrc1T9D5qs/JBUDURycYpUFoMZRVRPzJK/img.png](https://blog.kakaocdn.net/dn/QhzTY/btrc1T9D5qs/JBUDURycYpUFoMZRVRPzJK/img.png)
    
 ## 3.3 메서드

<aside>
🔥 매개변수 타입, 출력타입을 정해야한다! 메서드는 많이 만들어보는 것이 중요

</aside>

- 메서드란?

 - 간단하게 말해, { } 문장들을 작업 단위로 묶어 놓은 것(여러 문장으로 구성된 하나의 작업)

 - 메서드는 객체지향 개념에서 함수를 지칭하는 용어, 차이는 함수와 달리 메서드는 **꼭 클래스 안**에 있어야한다. 함수는 상관x, 독립적

### 메서드를 사용하는 이유

 1. 높은 재사용성

- 메서드는 한가지 기능만 수행하도록 작성하는 것이 좋다. 그래야 나중에 코드를 유지보수 할 때도 유리, 작업 단위일 때 재사용성 증가
- Java API에서 제공하는 메서드 사용

 2. 중복된 코드의 제거

- 똑같은 코드가 또 들어가는 것을 코드의 중복이라고 하는데, 프로그래밍에서는 이를 나쁘게 보기에 반드시 제거!
- 반복되는 문장들을 하나의 메서드로 작성. 그러면, 전체 소스 코드의 길이가 짧아져 변경 시 수정 코드의 양이 줄어들어 오류 발생 가능성 감소

=> static void 함수이름(타입 인수){ } 같은 것으로 블록화하여 코드 중복 시 그냥 함수이름(인수) [여기서 타입 작성x] 으로 메서드 호출(공유한다는 뜻)

```java
static void printArr(int[] numArr){
	for(int i=0; i<10;i++)
		System.out.printf("%d", numArr[i]);
	System.out.println();
}

//이후 main메서드에는 printArr(numArr);로 호출
```

 3. 프로그램의 구조화

- main 메서드에는 프로그램의 전체 흐름이 한 눈에 들어올 정도로 단순하게 구조화! ⇒ 문제 발생해도 쉽게 찾아서 해결 가능

      (즉, 사용할 메서드들을 main 메서드 밖에서 정의하면 좋다.)

<aside>
🔥 처음에 프로그램 설계 시, 내용이 없는 메서드를 작업단위로 만들고 하나씩 완성하는 것이 좋은 프로그램 구조화

</aside>


<br>

## 3.4 메서드의 선언과 구현

- 메서드는 선언부와 구현부로 이루어져있다.
    
    ![메서드와 매개변수의 구조](https://blog.kakaocdn.net/dn/LzExx/btrc2oVP4Kb/MS4nFCZEmRdopeUBw4KOK0/img.png)
    
    메서드와 매개변수의 구조
    
- 선언부는 반환타입(출력되는 타입) 메서드이름(타입 변수명, 타입 변수명,...)
- 특징
    
     - 메서드가 작업 수행을 위해 어떤 값들이 필요하고 작업의 결과로 어떤 타입 반환하는지 정보 제공 
    
     - 매개변수들에 타입 생략 불가. 반환값이 없으면 반환타입은 **void**
    
     - 매개변수가 없어도 되고, 여러개를 넣어도 된다. 많으면 배열이나 참조변수 사용
    
- 구현부:  { // 메서드 호출 시 수행될 코드}
- return문
    - 메서드의 반환타입이 void가 아니면, 구현부 안에 return 반환값이 무조건 포함(반환타입과 일치하거나 적어도 자동형변환 가능한 것이어야)
    - 작업을 수행한 결과인 반환값을 호출한 메서드로 전달한다.
    - return 반환값은 무조건 하나다. 작업결과가 여러 개면 객체에 담아서!
    - void여도 원래는 return; 이 있어야하나, 컴파일러가 자동 추가
    - if문을 쓰는 경우 조건식의 결과에 따라 return문이 실행되지않을 수도 있으니 else에도 추가
    
     // 삼항연산자를 사용해도 된다(어떻게든 return 결과값이 반환되게하면 된다.
    

 - 지역변수: 메서드 내에 선언된 변수. 서로 다른 메서드라면 같은 이름 사용 가능.

```java
ex) int add(int x, int y){ 
			int result = x+y; 
			return result; 
} 
// 라면 x와 y, result가 지역변수
// int add(int x, int y){
//			return x+y;
// 로 축약 가능
```

## 3.5 메서드의 호출

- 메서드 호출- 매개변수: parameter(영어로). 집어넣는 인자는 argument. 다만, 타입=, 자동형변환

## 매개변수가 있다면 

```java
 ex) int result = add (3,5);

// int add(int x, int y)를 호출하고, 결과를 result에 저장한다는 뜻
// (메서드 안에 있는 연산 진행하고나서 result에 저장하고 이를 return으로 반환)
// int result 부분없이 add(3,5) 만 있어도 되지만 작업결과를 어딘가 저장을 해야하기에 
// result 변수가 필요한 것이다. 에러가 나진 않는데, 메서드를 호출한 결과를 사용할 수 없다.
// 메서드를 호출하면 해당 메서드에 매개변수를 넣었다가 작업을 마치면 
// 그 결과를 호출한 곳에 다시 돌려준다. 그리고 호출한 곳이 작업결과로 변한다.SN.M,
```

## 메서드 호출방법: 먼저 클래스를 작성하고, 객체생성(클래스이름 변수명 = new 클래스이름();)

```java
class MyMath {
  long add(long a, long b) {
    long result = a+b;
    return result;
=> long subtract(long a, long b) {return a - b; } 와 같이 한 줄로 간단히 작성 가능
```

![메서드 호출과정. 메서드가 호출되면 지금까지 실행 중이던 메서드는 실행을 잠시 멈추고 호출된 메서드의 문장들이 실행되고, 작업이 끝나면 다시 호출한 메서드로 돌아와 이후의 문장들을 실행한다. 인자의 타입, 메서드 반환 타입, 호출한 자리의 타입 모두 같아야한다. (자동형변환 되든가)](https://blog.kakaocdn.net/dn/GGzoY/btrcXjH0YKw/Q1RWVwJ90cpew078LllrWk/img.png)

메서드 호출과정. 메서드가 호출되면 지금까지 실행 중이던 메서드는 실행을 잠시 멈추고 호출된 메서드의 문장들이 실행되고, 작업이 끝나면 다시 호출한 메서드로 돌아와 이후의 문장들을 실행한다. 인자의 타입, 메서드 반환 타입, 호출한 자리의 타입 모두 같아야한다. (자동형변환 되든가)

=⇒> 호출한 자리를 반환값이 대신하고 대입연산자에 의해 값이 변수 result1에 저장된다. 

### 에러 조심

1. 메서드 호출할 때, 참조변수 꼭 쓰기(객체이름.메서드이름(parameter);)

2. result와 같은 반환 값은 타입이 일치해야한다!!! 매우 주의!!!

ex) int add(int x, int y) {int result = x+y; return result;} 이면

 int result = mm.add(3,5); 와 같이 반환 값의 타입 일치!! 혹은 자동형변환 가능한 값으로!! 

ex) char, byte, short 같은 값들이 int로 자동 형변환 가능.===>> 매개변수, 반환타입, 반환값의 타입이 일치해야하는 것!!

3.  if문에서 참일때만 return문 쓰면 return 문 없다고 에러가 뜬다. 그러니 else 에도 return 문 필요!!

<aside>
🔥 **매개변수의 유효성 검사**: 매개변수 타입만 맞으면 어떤 값이든 들어올 수 있기에 메서드를 작성할 때, 모든 경우 대비해야한다. 예를 들어, 반환타입이 float인데, 분모를 0이 대입되면 안되기에 if문을 통해 return 0; 등을 통해 매개변수 유효하지않다고 메서드를 종료해야한다.

</aside>

## 3.7 JVM의 메모리 구조



1. **메서드 영역**

 - 프로그램 실행 중 어떤 클래스가 사용되면 JVM은 해당 클래스의 클래스파일을 읽고 분석하여 **클래스에 대한 정보**를 이곳에 저장한다. 이 때, 클래스 변수도 이 영역에!

1. **힙(heap)**

 - **인스턴스가 생성**되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성. 즉, 인스턴스 변수들이 생성되는 공간

1. **호출스택(call stack 또는 execution stack)**

 - 호출스택은 **메서드의 작업에 필요한** 메모리 공간을 제공. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리 할동. 이 메모리는 메서드가 작업 수행 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당된 메모리공간은 반환.

### 호출스택

// 매우 중요한 개념: 모든 프로그래밍 언어에서 공통적인 것.

- 스택(stack): 밑이 막힌 상자. 집어넣은 순서대로 위에 차곡차곡 쌓인다. 꺼낼 때는 위에서부터. (편의점 음료수 느낌?)
- 호출스택: 메서드 수행에 필요한 메모리가 제공되는 공간. 메서드가 호출되면 작업을 해야되는데 이에 필요한 메모리를 스택에 할당받는다. 작업이 끝나 종료되면 호출 스택에서 사용하던 메모리 공간 제거.
- 과정
    - 처음에 메인 메서드가 호출되어 스택에 올라가 있으면 실행 상태인데, 이 메서드가 다른 메서드를 호출하면 메인 메서드는 **대기 상태**가 되고, 다른 메서드가 실행 상태가 된다.
    - 그리고나서 다른 메서드가 작업을 마쳐 종료되면 스택에서 해당 공간이 사라져서 다시 메인 메서드로 돌아온다(다시 실행 상태) 이 메인 메서드도 종료가 되고 스택이 완전히 비워지면 프로그램을 종료하게 된다.
    - 스택을 보면 누가 누구를 호출했는지 알 수가 있어서 메서드들 간의 **호출 관계**를 알 수가 있다.
    
    중요: 하나의 스택에서는 하나의 메서드만 실행 중, 나머지는 대기하게 된다.
    
    ![호출스택과정 1](https://blog.kakaocdn.net/dn/bAjApl/btrc1dAwCad/1ezOkQJymxqhla9WNh3wjk/img.png)
    
    호출스택과정 1
    
    ![호출스택과정 2 JVM에 의해 main메서드가 호출되서 프로그램 시작. 호출 스택 비워지면 종료](https://blog.kakaocdn.net/dn/bDuW6K/btrc4ERsO0q/8mEikjrS1CkPwkhs9HCAak/img.png)
    
    호출스택과정 2 JVM에 의해 main메서드가 호출되서 프로그램 시작. 호출 스택 비워지면 종료
    

## 3.8 기본형 매개변수와 참조형 매개변수

### 기본형 반환타입

- 기본형 매개변수: 메서드의 매개변수 타입이 기본형: 변수의 값을 읽기만 할 수 있다(read only).
- 참조형은 저장된 주소에 접근하기 때문에 변경까지 가능!(read & write)

// int [] x 도 x는 int 타입의 배열의 참조변수이기 때문에 똑같이 해당한다. 

```java
ex) Data d = new Data(); d.x = 10; 
// 참조변수 d가 가리키는 객체의 x값을 10으로 바꾸는 것(객체 주소에 접근)
// 주소= 객체를 다룰 수 있는 리모컨을 준 것
```

- 스택에서 다른 메서드 간의 지역변수는 이름이 같아도, 서로 다르고, 서로 다른 저장공간(스텍 내)에 저장되는 것이다.
- ex)
    
    ![스택 헷갈림주의. 메인이 먼저 쌓이고 그다음 Data 클래스가!(호출을 먼저했으니)](https://blog.kakaocdn.net/dn/5WIQ0/btrc1U8Jci9/e4p6v39HF2cPejWkHKkjb1/img.png)
    
    스택 헷갈림주의. 메인이 먼저 쌓이고 그다음 Data 클래스가!(호출을 먼저했으니)
    
    ![순서 헷갈림 주의.  change에 있는 x가 1000인 된 이유: change에서 호출하고 작업을 수행하고나서 호출된 곳으로 값을 반환하기에.  sop 두번째 d.x가 10인 이유: 그 메서드 내에서 유효한 지역변수이기에. change(int x) 메서드 안에서 x=1000이라고 되어 있는데, 매개변수 변수가 선언 되어 있어서 x를 변수 선언 없이도 사용이 가능한 것](https://blog.kakaocdn.net/dn/bnigHp/btrcZtKBu4f/JaSBBjYfUusWxElXZPZ9XK/img.png)
    
    순서 헷갈림 주의.  change에 있는 x가 1000인 된 이유: change에서 호출하고 작업을 수행하고나서 호출된 곳으로 값을 반환하기에.  sop 두번째 d.x가 10인 이유: 그 메서드 내에서 유효한 지역변수이기에. change(int x) 메서드 안에서 x=1000이라고 되어 있는데, 매개변수 변수가 선언 되어 있어서 x를 변수 선언 없이도 사용이 가능한 것
    
    - change()에서 **main()에서 생성한 객체(원본)를 건드릴 수 있냐 없냐가 핵심이**다. [진짜 값만 읽어온 것]
    - change라는 메소드에서 매개변수로 받은 데이터가 기본형 이었으며 기본형 매개변수는 매개변수로 받은 값을 복사해서 메소드 안에서 사용했다가 메소드가 종료되면서 매개변수가 스택에서 제거되었기때문에 아무런 영향을 줄 수 없기에

![기본형 매개변수의 예제. 객체들이 호출스택에서 어떻게 생성되는지 보자. 그리고 main 메서드에 있는 건 d 객체의 주소이고, x값은 다른 곳에 저장되어있다. ]
기본형 매개변수의 예제. 객체들이 호출스택에서 어떻게 생성되는지 보자. 그리고 main 메서드에 있는 건 d 객체의 주소이고, x값은 다른 곳에 저장되어있다. 

![참조형 매개변수의 예제. 주소값을 매개변수로 주기 때문에 똑같이 참조하게된다.

참조형 매개변수의 예제. 주소값을 매개변수로 주기 때문에 똑같이 참조하게된다.

### 참조형 반환타입

<aside>
🔥 메서드의 반환 타입이 참조용일 경우에는. 객체의 주소를 반환(=참조형 타입의 값)하여 호출한 자리로 준다.

</aside>

ex) Date3 d2 = copy(d); // d2가 먼저 만들어집니다. 그리고 스택에서 copy 메서드 호출이 된다.
