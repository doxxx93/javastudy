================================== [ 7장 객체지향 프로그래밍 2] ==================================

[1. 상속(inheritance) ]

 # 1-1 상속의 정의와 장점
	* 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

	* 상속을 통해 적은 양의 코드로 새로운 클래스를 작성할 수 있다

	* 공통된 멤버를 가지고 있는 클래스를 작성할때 상속을 사용하면 코드의 양도 줄일 수 있고 중복 코드를 제거 할 수있다

	* 정의 방법 
		// class 하위클래스 extends 상위클래스 {...}

	* 하위클래스는 상위클래스의 모든 멤버를 가지고 있다
		// 생성자와 초기화 블럭은 상속되지 않는다 -> 멤버(변수, 메서드)만 상속된다		

	* 하위클래스는 별도의 멤버를 정의할 수 있다

 ★★★ 1-1.1 상속을 이용한 나만의 예제
	* 스터디 카페 체인점을 생각해서 각 지점에 공통적으로 있어야할 부분은 상위클래스로 작성하고
	  지점마다 다른 것들은 하위클래스로 작성한다
	
	* 상위클래스 스터디 카페의 변수 ?
		// 사물함 갯수, 카페존 좌석, 스터디존 좌석, 매출, a4용지 갯수(한달마다 공급하는 양이 같음 -> 명시적 초기화), 사용자수

	* 상위클래스의 메서드 ?
		// 프린트하기, a4용지 채우기, 사용좌석정리하기(정리하지 않으면 사용했던 좌석 사용불가)

	* 하위클래스 변수 ?
		// 얼음컵 수량, 간식수량, ....

	* 하위클래스 메서드 ?
		// 얼음컵 채우기, 간식채우기 ...

 # 1-2 클래스간의 관계 - 포함관계
	* 상속이외에 클래스를 재사용하는 방법

	* 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것

	* ex)	class Circle{
			Point c = new Point();	// 다른클래스 타입의 참조변수를 인스턴스변수로 선언
			int r; }		// 인스턴스변수

	* 포함관계로 다른 클래스를 사용할때의 장점
		// 단위별로 클래스들을 정의하고 이 클래스들을 포함관계로 재사용하면 간결하고 손쉽게 클래스를 작성할 수 있다
		
		// 작성된 단위 클래스들은 다른 클래스를 작성하는데도 재사용 될 수 있다

 # 1-3 클래스간의 관계 결정하기
	* 상속관계를 맺어 줄 것인지 포함관계를 맺어 줄 것인지 간단하게 결정하는 방법?

	* (A is a B) 상속관계 / (A has a B) 포함관계
		// A는 하위클래스 또는 포함하는 클래스 
		// B는 상위클래스 또는 포함당하는 클래스

		// 둘중 말이 되는 걸로 하면된다
		// 대부분은 포함관계로 한다.
			- 상속은 한개의 클래스 밖에 안되기 때문에 신중히 결정해야 하기 때문

	* ex) 원은 점이다 ? or 원은 점을 가지고 있다?
     				 ○

 # 1-4 단일 상속(single inheritance)
	* 자바는 오직 단일 상속만을 허용한다
		// 다중상속 X

	* 다중상속의 효과를 내려면 중요한 클래스는 상속을 받고, 다른 클래스들은 포함관계를 가지면 된다
		
 # 1-5 Object클래스 - 모든 클래스의 조상
	* Object 클래스는 상속계층도의 최상위에 있는 조상클래스이다

	* 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속을 받는다

	* toString(), equals(Object o)와 같은 메서드를 따로 정의 하지 않아도 사용할 수 있는 이유는
	  Object클래스에 정의된 것들이기 때문이다.

=======================================================================================================

[2. 오버라이딩(overriding) ]

 # 2-1 오버라이딩이란?
	* 조상클래스로부터 상속받은 메서드 내용을 자식클래스에 맞게 변경하는 것

 # 2-2 오버라이딩의 조건
	1. 상속받은 메서드와 선언부가 같아야 한다
		// 메서드 이름, 매개변수, 반환타입이 같아야한다

	2. 접근제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다
		// 조상클래스 메서드: public -> 오버라이딩된 자식클래스 메서드: private (X)
	
	3. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
		// Exception은 모든 예외의 최고 조상 이기 때문에 가장 많은 개수의 예외를 던질 수 있다

 # 2-3 오버로딩 vs 오버라이딩
	// 오버로딩 -> 새로운 메서드를 정의하는 것(new)
	// 오버라이딩 -> 상속받은 메서드의 내용을 변경하는 것(change, modify)

 # 2-4 참조변수 super
	* 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
		// 상속받은 멤버와 자신의 멤버가 이름이 같을 때는 super를 붙여서 구별

	* 모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this와 super의 값이 된다

	* 조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우 super를 사용해서 조상클래스 메서드를 사용할 수 있다
		// super.getScore() + ", age: " + age;
		// 오버라이딩한 메소드가 조상클래스 메서드의 내용에 추가적으로 작업을 덧붙이는 경우라면 이처럼 super를 사용해서
		   조상클래스의 메서드를 포함시키는 것이 좋다

 # 2-5 super() - 조상 클래스의 생성자
	* super()는 조상 클래스의 생성자를 호출하는데 사용

	* 모든 생성자는 첫 줄에 조상클래스의 생성자를 호출해야한다
		// 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상클래스의 멤버들이 먼저 초기화되어있어야

	* Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this() 또는 super()를 호출해야 한다.
	  그렇지 않으면 컴파일러가 자동적으로 super()를 생성자의 첫 줄에 삽입한다.

	* 조상클래스의 멤버변수를 자손 클래스의 인스턴스로 사용할때, 조상 클래스의 멤벼변수는 조상 생성자에 의해 초기화되도록 해야 한다.

 ★★ 2-5-1 나만의 예제 만들기 
	* 부모클래스, 자식클래스를 만들고 super, super()을 이용해 생성자 만들어보기

=======================================================================================================

[3. package와 import ]

 # 3-1 패키지(package) 
	* 패키지란 클래스의 묶음

	* 같은 이름의 클래스 일지라도 서로 다른 패키지에 존재하는 것이 가능

	* 클래스의 실제 이름은 패키지명을 포함한 것이다
		// String클래스의 실제 이름
			- java.lang.String

	* 패키지도 다른 패키지를 포함할 수 있으며 점(.)으로 구분한다.

 # 3-2 패키지의 선언
	* 패키지 선언문은 반드시 소스파일에서 주석과 공백을 제외한 첫 번째 문장이어야 한다
	
	* 하나의 소스파일에는 단 한번만 선언될 수 있다
	
	* 패키지이름은 대소문자를 모두 허용하지만, 소문자로 하는것이 원칙이다

	* 패키지를 지정하지 않으면 default 패키지에 속한다

 # 3-2-1 CMD에서 자바 실행하는 방법
	1. 실행하고자 하는 클래스의 패키지의 루트 디렉토리로 이동한다
	
	2. java 패키지명.클래스명

	* 루트 디렉토리를 클래스패스에 저장해놓으면 아무 위치에서나 실행이 가능하다
		// 시스템이 클래스패스를 돌면서 찾아보기때문
		// 환경변수편집 - 시스템변수 - 새로만들기 - 이름: classpath, 변수값:실행하고자하는 클래스가 있는 패키지의 루트디렉토리
		// 세미콜론(;)을 이용해서 여러개의 경로를 지정할 수 있다
		 
	* CMD에서 클래스패스 저장하는 방법
		// set classpath 패키지루트디렉토리;패키지루트디렉토리;

	* -cp옵션을 사용하면 경로를 저장안했거나, 해당 패키지의루트디렉토리가 아닐때 일시적으로 클래스패스를 지정해 줄 수 있다
		// java -cp 패키지의루트디렉토리 패키지명.클래스명

 # 3-3 import문
	* 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야한다

	* import문의 역할은 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것

	* 이클립스에서 단축키 ctrl + shift + o를 누르면 자도으로 import문을 추가해준다

 # 3-4 import문의 선언
	* import문의 위치
		// 1 package문, 2 import문, 3 클래스 선언

	* 같은 패키지에서 여러 개의 클래스가 사용될 때
		// 패키지명.* : 패키지에 있는 모든 클래스 사용가능
		// 패키지명1.패키지명2.*  : 패키지명2 에있는 모든 클래스 사용가능
		// 패키지명1.* : 패키지명1에 있는 모든클래스 사용가능
			- 패키지명2의 클래스는 사용 못한다
			  (하위패키지의 클래스는 포함되지 않는다)

	* import문을 지정하지 않으면 클래스를사용할때 패키지명도 함깨 적어줘야한다
		// java.util.Date now = new java.util.Date();

	* 모든파일은 lang패키지의 모든 클래스를 import 없이 사용 할 수 있다
		// 묵시적으로 선언되어 있음

 # 3-5 static import문
	* static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다
		// 특정 static 멤버를 자주 사용할 때 편리함
	
	* ex)
		int tmp = (int)(Math.random() * 10) +1;
		=> int tmp = (int)(random() * 10) +1;

		System.out.println("Hello Java");
		=> out.println("Hello Java");


	  